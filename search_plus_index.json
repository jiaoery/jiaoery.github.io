{"./":{"url":"./","title":"Introduction","keywords":"","body":" Hey, I'm jiaoery! I'm glad to see you ,my Vistor Let me introduce myself: ✍ recent activities 🌠Coding Time the projects I'm working on 🏆 Github Profile Trophy Watch my contribution graph get eaten by the snake 🐍 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-05-11 16:14:46 "},"Head-First-设计模式1-----策略模式.html":{"url":"Head-First-设计模式1-----策略模式.html","title":"Head-First-设计模式1-----策略模式","keywords":"","body":"本文参照《Head First 设计模式》，转载请注明出处 对于整个系列，我们按照这本书的设计逻辑，使用情景分析的方式来描述，并且穿插使用一些问题，总结的方式来讲述。并且所有的开发源码，都会托管到github上。 项目地址：https://github.com/jixiang52002/HFDesignPattern 1.引文 Joe的公司是做模拟鸭子活动的游戏而出名，这款游戏取名为SimUDuck，这款游戏具有非常多的鸭子，一边游泳一边呱呱叫。这里的设计采用了标准的OO（Object Oriented，面向对象）的方式编写，这里有一个鸭子的超类（SuperClass），后续所有的鸭子都必须继承这个超类。 OO面向对象模型 继承 这时，公司的高层们想要通过模拟会飞的鸭子来追求行业的领先。然后Joe的项目经理拍着胸脯告诉主管，Joe很快就可以搞定，“有了OO什么都不怕” Joe接收到任务后，想出了一个办法：“我仅需要在Duck这个超类中加上Fly()的方法，然后所有的鸭子都可以飞了”。然后他的设计模型就改成以下的样子 这样看起来貌似没有什么问题的，然后可怕的问题发生了。。。。 用户反馈，自己的橡皮鸭和木鸭居然也可以飞起来！！！ 那么，到底是为何导致了这个可怕的问题？ 我们来分析一下：由于Joe在Duck超类中加上fly方法，导致所有的子类都会继承该方法，这就导致了原本不会飞的橡皮鸭和木鸭也具有飞行能力，显然为了提高复用性使用的继承方式，并未达到完美得结果。 继承+覆盖 Joe在思考后，又得出一个方案，那就是在橡皮鸭中将fly方法覆盖掉，不做任何操作，这样原有的RubberDuck类中架构就变成如下： 然后，业务的需求又需要加入木鸭（DecoyDuck），它不会叫也不会飞。苦逼的Joe又要把木鸭（DecoyDuck)中quark方法覆盖，这样DecoyDuck中的类结构就变成如下： 但是我们会发觉，如果以后有新的业务，甚至于fly方法中出现一个bug，或者需要删除fly相关的业务，所有相关代码都需要修改，在大型项目中，这都导致非常可怕的维护问题。那么，到底该怎么办 接口 “这不就相当于让我根据用户手机壳颜色换主题吗？”，可怜的Joe在快被想要冲上去打产品经理的时候（皮一下。。。）。脑子突然想起一件神器，他决定试试。他的方法就是使用接口（Interface），将fly分离出来，放进一个Flyable接口中。针对于quark方法，也可以这样分离进Quarkable接口中， 虽然这样看起来满足了我们之前所提到的所有需求，但是这样一来重复代码量会非常可怕，如果有上万个Duck子类，Joe一定会发疯的。所有，这个方法虽然看起来很好，但是一旦某个方法或者行为发生改变，我们需要定位到所有实现该方法的类中去修改对应的代码，这很容易导致bug的发生。 那么，到底有没有一种能够建立软件的有效方法，能够让我们可以对既有的项目在影响最小的情况下修改他的业务逻辑，这样我们能够花很少的时间去修改代码。 2.策略模式 第一设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混合在一起。 按照以上的原则进行设计，代码发生变化引起的后果会非常小，整个项目会特别具有弹性。 这个原则不仅仅适用于策略模式，对于之后讲解的模式同样也是核心的指导方向。那么我们继续Joe所遇到的Duck问题。 2.1分开变化的和不会变化的 我们很清楚，Duck类内部的fly()和quark()伴随着鸭子的不同会发生改变，其他模块是不变的。为了要把这两个变化的行为从Duck类中分开，我们把它们从Duck类中抽离出来，建议一组新类用来代表每一个行为。 那么，问题来了。如何设计那组实现飞行行为和呱呱叫行为的一组类呢？ 这里就需要提及第二设计原则 第二设计原则 针对于接口编程，不针对实现编程 这里我们希望的是在创建具体的Duck类的时候，可以动态的生成对应的行为。打个比方，我们想要产生一个新的绿头鸭，将制定类型的飞行行为赋予给它。这就说明，在Duck类中，我们需要包含定义Duck行为的方法，这样在运行的时候，我们就可以动态去改变绿头鸭的行为。 所以这里我们使用两个接口来代表两个行为，这里定义为 FlyBehavior和QuarkBehavior，行为的每次实现，都将实现对应的接口。 但是接口类是没有方法体的，也就是说，我们需要一组类实现对应的行为，这些专用来实现类似FlyBehavior和QuarkBehavior的一组类，我们称为行为类。 这里提到的接口类并非严格意义上Java中的接口（Interface），可以理解为抽象类或接口。这里我们可以理解为： \"针对接口编程\"真正的意思是“针对超类型（supertype）编程” 这里讲得有点难以理解，我们对比一下针对实现编程和针对接口编程的区别： //针对实现编程 Dog dog=new Dog(); dog.bark(); //针对接口编程 Animal animal=new Dog(); animal.makeSoud(); 2.2实现鸭子的行为（代码） 从上面的讲解，我们可以理解可变部分是fly和quack两种方法。不可变为Duck类。那么这里我们需要使用两个接口FlyBehavior和QuackBehavior，还有一些列他们对应的行为类，具体的结构逻辑如下图： 这设计有两个很明显的优势： 可以让飞行和呱呱的叫的动作可以被其他对象复用，因为这些行为已经与鸭子类无关。也就是解耦 我们能够在不影响原有的行为类的情况下新增一些行为。也就是具备了弹性和可拓展性 拓展几个概念： 耦合指的就是两个类之间的联系的紧密程度 解耦指的是解除类之间的直接关系，将直接关系转换成间接关系 想要了解的可以参考这篇文章：https://blog.csdn.net/qq_24499615/article/details/77821896 接下来分别将FlyBehavior,FlyWithWings,FlyNoWay分别贴下 ``` public interface FlyBehavior { //飞行 public void fly(); } public class FlyWithWings implements FlyBehavior{ public void fly() { System.out.println(\"I am flying!\"); } } ``` public class FlyNoWay implements FlyBehavior { public void fly() { System.out.println(\"I can't fly!\"); } } 接下来将QuackBehavior，Quack，MuteQuack，Squeak类的代码分别贴下： public interface QuackBehavior { //呱呱叫 public void quack(); } public class Quack implements QuackBehavior { public void quack() { System.out.println(\"Quack\"); } } public class MuteQuack implements QuackBehavior { public void quack() { System.out.println(\">\"); } } public class Squeak implements QuackBehavior { public void quack() { System.out.println(\"Squeak\"); } } 到这里将fly和quack的接口类和行为类完成。 2.3组合鸭子行为 在前面2.2我们将飞行（fly）和呱呱叫（quack）的动作\"委托\"（delegate）给其他接口类处理，而并非在Duck类（或者子类）中定于fly和quack方法。那么到底该怎么把行为组合进Duck中？ 1.首先在Duck类中增加两个“实例变量”，分别为flyBehavior和quackBehavior，声明为接口类型（注意不是具体类的实现类型），每个Duck（或其子类）会动态的设置这些变量以在运行时引用正确的行为类型（如FlyWithWings，Squeak等）。Duck类的类结构如下 2.那么，就开始实现Duck类 public abstract class Duck { //为行为接口类型声明两个引用变量，所有的鸭子（或子类）都继承它们 FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck(){ } public abstract void display(); public void performQuck(){ //委托给行为处理 quackBehavior.quack(); } public void performFly(){ //委托给行为处理 flyBehavior.fly(); } public void swim(){ System.out.println(\"All ducks float\"); } } 然后我们实现一个MallardDuck类来实现组合， public class MallardDuck extends Duck{ public MallardDuck(){ //使用FlyWithWings作为其FlyBehavior类型 flyBehavior=new FlyWithWings(); //绿头鸭使用Quck类处理呱呱叫， //所以当performQuack被调用时，叫这个行为被委托给Quck对象 quackBehavior=new Quack(); } /* * 因为MallardDuck继承自Duck类 * ，所以具备flyBehavior与quackBehavior实例变量 */ public void display() { // TODO Auto-generated method stub } } 当然构造器内还是需要实现具体行为类，这在之后的模式中会提供相应的解决方案，之后我们会回归到这个问题继续解决这个问题。 到这里，组合鸭子类已经实现。 3.测试效果 这里我们编译测试类 ``` public class MiniDuckSimilator { public static void main(String[] args) { Duck mallerdDuck=new MallardDuck(); //一下代码是将具体的行为委托给对应的行为类处理行为 mallerdDuck.performQuck(); mallerdDuck.performFly(); } } ![运行结果](https://upload-images.jianshu.io/upload_images/2326194-d4b68c3aeb1df28f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) #2.4 动态行为设定 在之前的实现中我们是在Duck的具体子类中实现FlyBehavior和QuackBehavior的行为，但是Duck失去了动态设定的功能，对于追求完美的程序员来说是不可饶恕的。所以急切需要通过一个方法动态设定行为，而并非是在鸭子（Duck）的构造器中去实例化。这里推荐一个方法-----**设定方法（setter method）** * 1. 在Duck类中增加两个新方法 setFlyBehavior()和setQuckBehavior().对于Duck的类结构修改如下 ![image.png](https://upload-images.jianshu.io/upload_images/2326194-7d5c581118a4372b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 具体修改如下 public abstract class Duck { //为行为接口类型声明两个引用变量，所有的鸭子（或子类）都继承它们 FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck(){ } public abstract void display(); public void performQuck(){ //委托给行为处理 quackBehavior.quack(); } public void performFly(){ //委托给行为处理 flyBehavior.fly(); } public void setFlyBehavior(FlyBehavior flyBehavior){ this.flyBehavior=flyBehavior; } public void setQuackBehavior(QuackBehavior quackBehavior){ this.quackBehavior=quackBehavior; } public void swim(){ System.out.println(\"All ducks float\"); } } * 2.创建一个新的鸭子模型：模型鸭（ModelDuck） public class ModelDuck extends Duck{ public ModelDuck(){ flyBehavior=new FlyNoWay(); quackBehavior=new Quack(); } public void display() { System.out.println(\"I'm a model duck\"); } } * 3.新建立一个新的FlyBehavior类型 FlyRocketPowered public class FlyRocketPowered implements FlyBehavior{ public void fly() { System.out.println(\"I'm flying with a rocket!\"); } } * 4.修改测试类MiniDuckSimulator，加上模型鸭，并令模型鸭具备火箭动力 public class MiniDuckSimilator { public static void main(String[] args) { Duck mallerdDuck=new MallardDuck(); //一下代码是将具体的行为委托给对应的行为类处理行为 mallerdDuck.performQuck(); mallerdDuck.performFly(); Duck modelDuck=new ModelDuck(); //第一次会使用构造参数里的飞行模式 modelDuck.performFly(); modelDuck.setFlyBehavior(new FlyRocketPowered()); //模型鸭具备火箭飞行能力 modelDuck.performFly(); } } ``` 运行结果： 到这里我们发现鸭子模型中我们使用到类的组合使用，而这里我们涉及到第三个设计原则： 第三个设计原则 多用组合，少用继承 正如我们所见，组合所建立的系统具备极大的弹性，不仅仅可以将行为封装为一系列的行为类，更可以动态改变行为，只需要组合的行为对象是符合正确的行为接口标准的。 3.策略模式讲解 总结之前的三个设计原则： 第一设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混合在一起。 第二设计原则 针对于接口编程，不针对实现编程 第三设计原则 多用组合，少用继承 总结这三条原则结合起来就是我们学习的第一个模式： 策略模式 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-12 15:58:12 "},"Head-First-设计模式2---观察者（Observer）模式.html":{"url":"Head-First-设计模式2---观察者（Observer）模式.html","title":"Head-First-设计模式2---观察者（Observer）模式","keywords":"","body":"本文参照《Head First 设计模式》，转载请注明出处 对于整个系列，我们按照这本书的设计逻辑，使用情景分析的方式来描述，并且穿插使用一些问题，总结的方式来讲述。并且所有的开发源码，都会托管到github上。 项目地址：https://github.com/jixiang52002/HFDesignPattern 前一章主要讲解了设计模式入门和最常用的一个模式-----策略模式，并结合Joe的鸭子模型进行分析，想要了解的朋友可以回去回看一下。 这里我们将继续介绍一种可以帮助对象知悉现状，不会错过该对象感兴趣的事。甚至对象可以自己决定是都要继续接受通知。有过设计模式学习经验的人会脱口而出-----观察者模式。对的，接下来我们将了解一个新的设计模式，也就是观察者模式。 1.引言 最近你的团队获取了一个新的合约，需要负责建立一个Weather-O-Rama公司的下一代气象站----Internet气象观测站。 合约内容如下： 恭喜贵公司获选为敝公司建立下一代Internet气象观测站！该气象站必须建立在我们专利申请的WeatherData对象上，由WeatherData对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望贵公司能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。当WeatherData对象获取到最新的测量数据时，三种布告板必须实时更新。 而且，这是一个可以拓展的气象站，Weather-O-Rama气象站希望公布一组API，让其他开发人员可以写出自己的气象布告板，并插入此应用中我们希望贵公司可以提供这样的API。 Weather-O-Rama气象站有很好的商业运营模式：一旦客户上钩，他们使用每个布告板都要付钱最好的部分就是，为了感谢贵公司建立此系统，我们将以公司的认股权支付你。 我们期待看到你的设计和应用的alpha版本。 附注：我们正在通宵整理WeatherData源文件给你们。 1.1需求分析 根据开发的经验，我们首先分析Weather-O-Rama公司的需求： 此系统有三个部分组成：气象站（获取实际的气象数据的物理组成），WeatherData对象（追踪来自气象站的数据，并更新布告板）和布告板（显示目前天气状况展示给用户） 项目应用中，开发者需要利用WeatherData去实时获取气象数据，并且更新三个布告板：目前气象，气象统计和天气预报。 系统必须具备很高的可拓展性，让其他的开发人员可以建立定制的布告板，用户可以随心所欲地添加或删除任何布告板。 我们初始设计结构如下： 1.2WeatherData类 第二天，Weather-O-Rama公司发送过来WeatherData的源码，其结构如下图 其中measurementsChanged（）方法在气象测试更新时，被调用。 1.3错误的编码方式 首先，我们从大部分不懂设计模式的开发者常用的设计方式开始。 根据Weather-O-Rama气象站开发人员的需求暗示，在measurementsChanged()方法中添加相关的代码： public class WeatherData { private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 private CurrentConditionsDisplay currentConditionsDisplay;//目前状态布告板 private StatisticsDisplay statisticsDisplay;//统计布告板 private ForecastDisplay forecastDisplay;//预测布告板 public WeatherData(CurrentConditionsDisplay currentConditionsDisplay ,StatisticsDisplay statisticsDisplay ,ForecastDisplay forecastDisplay){ this.currentConditionsDisplay=currentConditionsDisplay; this.statisticsDisplay=statisticsDisplay; this.forecastDisplay=forecastDisplay; } public float getTemperature() { return temperature; } public float getHumidity(){ return humidity; } public float getPressure(){ return pressure; } //实例变量声明 public void measurementsChanged(){ //调用WeatherData的三个getter方法获取最近的测量值 float temp=getTemperature(); float humidity=getHumidity(); float pressure=getPressure(); currentConditionsDisplay.update(temp,humidity,pressure); statisticsDisplay.update(temp,humidity,pressure); forecastDisplay.update(temp,humidity,pressure); } //通知发生变化 public void setMeasurements(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; measurementsChanged(); } } 回顾第一章的三个设计原则，我们发现这里违反了几个原则 第一设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混合在一起。 第二设计原则 针对于接口编程，不针对实现编程 第三设计原则 多用组合，少用继承 在这里我们使用了针对实现编程，并且没有将变化部分独立出来，这样会导致我们以后在增加或删除布告板时必须修改应用程序。而且，最重要的是，我们牺牲了可拓展性。 既然这里我们提到了要使用观察者模式来解决问题，那么该如何下手。并且，什么是观察者模式？ 2.观察者模式 2.1认识观察者模式 为了方便理解，我们从日常生活中常遇到的情形来理解观察者模式，这里我们使用生活常见的报纸和杂志订阅业务逻辑来理解： 报社的业务在于出版报纸 订阅报纸的用户，只要对应报社有新的报纸出版，就会给你送来 当用户不想继续订阅报纸，可以直接取消订阅。那么之后就算有新的报纸出版，也不会送给对应用户了。 只要报社一直存在，任何用户都可以自由订阅或取消订阅报纸 从上面的逻辑我们分析出，这里由以下部分组成，报社，用户，订阅。将其抽象出来就i是：出版者，订阅者，订阅。这里观察者模式的雏形已经出来了。 出版者+订阅者=观察者模式 如果上面已经理解了报社报纸订阅的逻辑，也可以很快知道观察者模式是什么。只是在其中名称会有差异，前面提到的“出版者”我们可以称为“主题（Subject）”或“被观察者（Observable）”（后一个更加常用），“订阅者”我们称为“观察者（Observer）”，这里我们采用类UML的结构图来解释： 2.2 观察者模式注册/取消注册 场景1： 某一天，鸭子对象觉得自己的朋友都订阅了主题，自己也想称为一个观察者。于是告诉主题，它想当一个观察者。完成订阅后，鸭子也成为一个观察者了。 这样当主题数据发生变化时，鸭子对象也可以得到通知了！！ 场景2： 老鼠对象厌烦了每天都被主题烦，决定从观察者序列离开，于是它告诉主题它想离开观察者行列，主题将它从观察者中除名。 之后主题数据发生变化时，不会再通知老鼠对象。 上面的两个情形分别对应了注册和取消注册，这也是观察者模式最重要的两个概念。注册后的对象我们才可以称为观察者。观察者取消注册后也不能称为观察者。 2.3 观察者模式定义 通过报纸业务和对象订阅的例子，我们可以勾勒出观察者模式的基本概念。 观察者模式定义了对象之间的一对多的依赖，这样一来，当一个对象改变状态时，它所有的依赖者都会收到通知并自动更新。 主题/被观察者和观察者之间定义了一对多的关系。观察者依赖于主题/被观察者。一旦主题/被观察者数据发生改变的时候，观察者就会收到通知。那么，如何实现观察者和主题/被观察者呢？ 2.4 观察者模式实现 由于网络上的实现观察者的方式非常多，我们这里采取比较容易理解的方式Subject和Observer。对于更高级的使用方式，可以百度。 接下来我们来看看基于Subject和Observer的类图结构： 3. 设计气象站 到这里我们再回到当初的问题，气象站中结构模型为一对多模型，其中WeatherData为气象模型中的“一”，而“多”也就对应了这里用来展示天气监测数据的各种布告板。相对于之前的针对实现的方式，使用观察者模式来设计会更加符合需求。优先我们给出新的气象站模型。 3.1实现气象站 依照前面的设计结构图，最终来实现具体代码结构 1.Subject public interface Subject { //注册观察者 public void registerObserver(Observer o); //删除观察者 public void removeObserver(Observer o); //当主题发生数据变化时，通知所有观察 public void notifyObservers(); } 2.Observer public interface Observer { /** * * update:当气象站的观测数据发生改变时，这个方法会被调用 * @param temp 温度 * @param hunmidity 湿度 * @param pressure 气压 * @since JDK 1.6 */ public void update(float temp,float hunmidity,float pressure); } 3.DisplayElement public interface DisplayElement { //当布告板需要展示时，调用此方法时 public void display(); } 4.新的WeatherData1 public class WeatherData1 implements Subject{ private ArrayList observers; private float temperature; private float humiditty; private float pressure; public WeatherData1(){ observers=new ArrayList(); } //注册 public void registerObserver(Observer o) { observers.add(o); } //删除 public void removeObserver(Observer o) { int i=observers.indexOf(o); if(i>=0){ observers.remove(i); } } //通知观察者数据变化 public void notifyObservers() { for(int i=0;i5.CurrentConditionsDisplay public class CurrentConditionsDisplay implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData){ this.weatherData=weatherData; weatherData.registerObserver(this); } /** * * update:更新布告板内容 * @author 吉祥 * @param temperature * @param humidity * @param pressure * @since JDK 1.6 */ public void update(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; display(); } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Current conditons:\"+temperature +\"F degrees and \"+humidity+\"% humidity\"); } } 6.ForecastDisplay public class ForecastDisplay implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Subject weatherData; public ForecastDisplay(Subject weatherData){ this.weatherData=weatherData; weatherData.registerObserver(this); } /** * * update:更新布告板内容 * @author 吉祥 * @param temperature * @param humidity * @param pressure * @since JDK 1.6 */ public void update(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; display(); } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Forecast: More of the same\"); } } 7.StatisticsDisplay public class StatisticsDisplay implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Subject weatherData; public StatisticsDisplay(SubjectweatherData){ this.weatherData=weatherData; weatherData.registerObserver(this); } /** * * update:更新布告板内容 * @author 吉祥 * @param temperature * @param humidity * @param pressure * @since JDK 1.6 */ public void update(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; display(); } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Avg/Max/Min temperature= \"+temperature +\"/\"+temperature+\"/\"+temperature); } } ps:这里在Observer中使用Subject原因在于方便以后的取消注册。 最后我们建立一个测试类WeatherStation来进行测试 public class WeatherStation { public static void main(String[] args){ WeatherData1 weatherData=new WeatherData1(); CurrentConditionsDisplay currentConditionsDisplay=new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay=new StatisticsDisplay(weatherData); ForecastDisplay forecastDisplay=new ForecastDisplay(weatherData); weatherData.setMeasurements(80, 65, 30.4f); weatherData.setMeasurements(82, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.2f); } } 最终结果如下 到这里我们已经讲解完观察者模式的一种实现方式。但是这我们也提出一个问题，用来发散。 是否能够在主题中提供向外的可以让观察者自己获取自己想要数据，而并非将所有的数据都推送给观察者？也就是在Push（推）的同时我们也可以pull（拉）。 4.Java内置的观察者模式 刚才的问题，其实熟悉Java语言的开发者会发现，在Java中已经有相应的模式，如果熟悉的可以直接跳过本章。 在java.util包下有Observer和Observable类，这两个类的结构跟我们遇到的Subject和Observer模型有些类似。甚至可是随意使用push（推）或者pull（拉） 这里我们使用在线的Java API网站在线Java API文档 首先查询Observer的API 这个与我们所写的Observer结构几乎相同，只是在推送是把Observable类一起推送，这样用户既可以push也可以使用pull的方式。那么Observable的结构呢 我们发现这里Observable是类与我们之前Subject作为接口的方式稍微有区别；并且Observable类其他方法更全。那么使用类的方式和使用接口的影响我们在后面会继续讲。并且这里我们关注setChanged（）方法告诉被观察者的数据发生改变 那么，如果要使用Java中自带的观察者模式来修改原有气象站业务会如何。 首先，我们来分析更改后气象站的模型： 4.1Java内置观察者模式运作模式 相对于于之前Subject和Observer的模式，Java内置自带的观察者模式运行稍微有些差异。 将对象变成观察者只需要实现Observer（java.util.Observer）接口，然后调用任何Observable的addObserver()方法即可。如果要删除观察者，调用deleteObserver()即可。 被观察者若要推送通知，需要对象继承Observable（java.util.Observable）类，并先调用setChanged(),首先标记状态已经改变。然后调用notifyObservers()方法中的一个：notifyObservers()(通知观察者pull数据)或notifyObserers(Object object)(通知观察者push数据) 那么作为观察者如何处理被观察者推送出的数据呢。 这里逻辑如下： 观察者（Observer）必须在update（Observable o,Object object）.前一个参数用来让观察者知道是哪个被观察者推送数据。后一个object为推送数据，允许为null。 4.2 setChanged() 在Observable类中setChanged()方法一开始我也有疑惑，为何在推送之前需要调用该方法。后来查阅资料和Java API发现它很好的一个用处。我们先来查看java的源码 这里必须标记为true才会推送消息，那么这个到底有何好处，我们拿气象站模型来分析。 如果没有setChanged方法，也是之前的Subject和Observer模型里，一旦数据发生细微的变化，我们都会对所有的观察者进行推送。如果我们需要在温度变化1摄氏度以上才发送推送，调用setChanged（）方法更加有效。当然，这个功能使用场景很少，但是也不排除会用到。当然更改Object和Observer模型也是可以做到这个效果的！！！ 4.3 Java内置观察者更改气象站 那么利用气象站模型来实际操作一下，依照之前的模型我们代码应该如下 1.WeatherData2 public class WeatherData2 extends Observable{ private float temperature; private float humidity; private float pressure; //构造器不需要为了记住观察者建立数据模型 public WeatherData2(){ } public void measurementsChanged(){ //在调用notifyObserver()需要指示状态已经更改了 setChanged(); //这里未使用notifyObserver(object),所以数据采用拉的逻辑 notifyObservers(this); } public void setMeasurements(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; measurementsChanged(); } //以下方法为pull操作提供 public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; } } 2.CurrentConditionsDisplay1 public class CurrentConditionsDisplay1 implements Observer,DisplayElement{ private Observable observable; private float temperature; private float humidity; private float pressure; //构造器需要传入Observable参数，并登记成为观察者 public CurrentConditionsDisplay1(Observable observable){ this.observable=observable; observable.addObserver(this); } //update方法增加Observable和数据对象作为参数 public void update(Observable o, Object arg) { if(arg instanceof WeatherData2){ WeatherData2 weatherData2=(WeatherData2) arg; this.temperature=weatherData2.getTemperature(); this.humidity=weatherData2.getHumidity(); this.pressure=weatherData2.getPressure(); display(); } } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Current conditons:\"+temperature +\"F degrees and \"+humidity+\"% humidity\"); } } 3.ForecastDisplay1 public class ForecastDisplay1 implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Observable observable; public ForecastDisplay1(Observable observable){ this.observable=observable; observable.addObserver(this); } public void update(Observable o,Object arg){ if(arg instanceof WeatherData2){ WeatherData2 weatherData2=(WeatherData2) arg; this.temperature=weatherData2.getTemperature(); this.humidity=weatherData2.getHumidity(); this.pressure=weatherData2.getPressure(); display(); } } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Forecast: More of the same\"); } } 4.StatisticsDisplay1 public class StatisticsDisplay1 implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Observable observable; public StatisticsDisplay1(Observable observable){ this.observable=observable; observable.addObserver(this); } public void update(Observable o,Object arg){ if(arg instanceof WeatherData2){ WeatherData2 weatherData2=(WeatherData2) arg; this.temperature=weatherData2.getTemperature(); this.humidity=weatherData2.getHumidity(); this.pressure=weatherData2.getPressure(); display(); } } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Avg/Max/Min temperature= \"+temperature +\"/\"+temperature+\"/\"+temperature); } } 最后进行测试： WeatherStation1 public class WeatherStation1 { public static void main(String[] args){ WeatherData2 weatherData=new WeatherData2(); CurrentConditionsDisplay1 currentConditionsDisplay=new CurrentConditionsDisplay1(weatherData); StatisticsDisplay1 statisticsDisplay=new StatisticsDisplay1(weatherData); ForecastDisplay1 forecastDisplay=new ForecastDisplay1(weatherData); weatherData.setMeasurements(80, 65, 30.4f); weatherData.setMeasurements(82, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.2f); } } 结果最终如下： 我们对比之前Subject和Observer的观察者模式会发现两者输出顺序不一样，这是为什么？ 其实java.util.Observable不依赖于观察者被通知的顺序的，并且实现了他的notifyObserver()方法，这会导致通知观察者的顺序不同于Subject和Observer模型在具体类实现notifyObserver()方法。其实两者都没有任何的代码误差，只是实现的方式不同导致不同的结果。 但是java.util.Observable类却违背了之前第一章中针对接口编程，而非针对实现编程。恐怖的是，它也没有接口实现，这就导致它的使用具有很高的局限性和低复用性。如果一个对象不仅仅是被观察者，同时还是另一个超类的子类的时候，我们无法使用多继承的方式来实现。我们如果自行拓展的话，你会发现setChanged()方法是protected方法，这就表示只有java.util.Observable自身和其子类才可以使用这个方法。这就违反了第二个设计原则---------\"多用组合，少用继承\"。这也是我一般不会使用Java自带的设计者模式的原因。 现在比较流行的观察者模式，也就是RxJava，但是由于这个框架涉及不仅仅有观察这模式，在之后整个设计模式整理玩不后，我会集中再讲。 5.总结 到此，观察者模式的讲解已经全部讲解完成。总结一下。 第四设计原则 为交互对象之间的松耦合涉及而努力 观察者模式 在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。 相应的资料和代码托管地址https://github.com/jixiang52002/HFDesignPattern Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-12 15:58:12 "},"Head-First-设计模式3----装饰者模式.html":{"url":"Head-First-设计模式3----装饰者模式.html","title":"Head-First-设计模式3----装饰者模式","keywords":"","body":"本文参照《Head First 设计模式》，转载请注明出处 对于整个系列，我们按照这本书的设计逻辑，使用情景分析的方式来描述，并且穿插使用一些问题，总结的方式来讲述。并且所有的开发源码，都会托管到github上。 项目地址：https://github.com/jixiang52002/HFDesignPattern 回顾上一篇文章讲解了设计模式中常用的一种模式------观察者模式。并结合气象站设计进行实战解析，并且从自己设计到JAVA自带设计模式做了讲解。想要了解的朋友可以回去回看一下。 本章我们会继续前面的话题，有关典型的继承滥用问题。这一章会讲解如何使用对象组合的方式，如何在运行时候做装饰类。在熟悉装饰技巧后，我们能够在原本不修改任何底层的代码，却可以给原有对象赋予新的职能。你会说，这不就是“装饰者模式”。没错，接下来就是装饰者模式的ShowTime时间。 前言 欢迎来到星巴兹咖啡，该公司是世界上以扩张速度最快而闻名的咖啡连锁店。但是最近这家著名的咖啡公司遇到一个巨大的问题，因为扩展速度太快了，他们准备更新订单系统，以合乎他们的饮料供应需求。 他们本来的设计方式如下： 然后客户购买咖啡时，可以要求在其中加入任何调料，例如：奶茶，牛奶，豆浆。星巴兹根据业务需求会计算相应的费用。这就要求订单系统必须考虑到这些调料的部分。 然后我们就看到他们的第一个尝试设计： 是不是有一种犯了密集恐惧症的感觉，整完全就是“类爆炸”。 那么我们分析一下，这种设计方式违反了什么设计原则?没错，违反了以下两个原则: 第二设计原则 针对于接口编程，不针对实现编程 第三设计原则 多用组合，少用继承 那么我们应该怎么修改这个设计呢？ 利用继承对Beverage类进行改造 首先，我们考虑对基类Beverage类进行修改，我们根据前面“类爆炸”进行分析。主要饮料包含各种调料（牛奶，豆浆，摩卡，奶泡。。。。）。 所以修改后的Beverage类的结构如下： Beverage类具体实现如下： public class Beverage { protected String description;//饮料简介 protected boolean milk=false;//是否有牛奶 protected boolean soy=false;//是否有豆浆 protected boolean cocha=false;//是否有摩卡 protected boolean whip=false;//是否有奶泡 protected double milkCost=1.01;//牛奶价格 protected double soyCost=1.03;//豆浆价格 protected double cochaCost=2.23;//摩卡价格 protected double whipCost=0.89;//奶泡价格 public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public boolean hasMilk() { return milk; } public void setMilk(boolean milk) { this.milk = milk; } public boolean hasSoy() { return soy; } public void setSoy(boolean soy) { this.soy = soy; } public boolean hasCocha() { return cocha; } public void setCocha(boolean cocha) { this.cocha = cocha; } public boolean hasWhip() { return whip; } public void setWhip(boolean whip) { this.whip = whip; } public double getCochaCost() { return cochaCost; } public void setCochaCost(double cochaCost) { this.cochaCost = cochaCost; } public double getWhipCost() { return whipCost; } public void setWhipCost(double whipCost) { this.whipCost = whipCost; } public double cost(){ double condiments=0.0; if(hasMilk()){//是否需要牛奶 condiments+=milkCost; } if(hasSoy()){//是否需要豆浆 condiments+=soyCost; } if(hasCocha()){//是否需要摩卡 condiments+=cochaCost; } if(hasWhip()){//是否需要奶泡 condiments+=whipCost; } return condiments; } } 实现其中一个子类DarkRoast： public class DarkRoast extends Beverage{ public DarkRoast(){ description=\"Most Excellent Dark Roast!\"; } public double cost(){ return 1.99+super.cost(); } } 看起来很完美，也能满足现有的业务需求，但是仔细思考一下，真的这样设计不会出错？ 回答肯定是会出错。 第一，一旦调料的价格发生变化，会导致我们队原有代码进行大改。 第二，一旦出现新的调料，我们就需要加上新的方法，并需要改变超类Beverage类中cost（）方法。 第三，如果星巴兹咖啡研发新的饮料。对于这些饮料而言，某些调料可能并不合适，但是子类仍然会继承那些本就不合适的方法，例如我就想要一杯水，加奶泡（hasWhip）就不合适。 第四，如果用户需要双倍的摩卡咖啡，又应该怎么办呢？ 开放-关闭原则 到这里，我们可以推出最重要的设计原则之一： 第五设计原则 类应该对拓展开放，对修改关闭。 那么什么是开放，什么又是关闭？开放就是允许你使用任何行为来拓展类，如果需求更改（这是无法避免的），就可以进行拓展！关闭在于我们花费很多时间完成开发，并且已经测试发布，针对后续更改，我们必须关闭原有代码防止被修改，避免造成已经测试发布的源码产生新的bug。 综合上述说法，我们的目标在于允许类拓展，并且在不修改原有代码的情况下，就可以搭配新的行为。如果能实现这样的目标，带来的好处将相当可观。在于代码会具备弹性来应对需求改变，可以接受增加新的功能用来实现改变的需求。没错，这就是拓展开放，修改关闭。 那么有没有可以参照的实例可以分析呢？有，就在第二篇我们介绍观察者模式时，我们介绍到可以通过增加新的观察者用来拓展主题，并且无需向原主题进行修改。 我们是否需要每个模块都设计成开放--关闭原则？不用，也很难办到（这样的人我们称为“不用设计模式会死病”）。因为想要完全符合开放-关闭原则，会引入大量的抽象层，增加原有代码的复杂度。我们应该区分设计中可能改变的部分和不改变的部分（第一设计原则），针对改变部分使用开放--关闭原则。 装饰模式 这里，就到了开放--关闭原则的运用模式-----装饰者模式。首先我们还是从星巴兹咖啡的案例来做一个简单的分析。 分析之前两个版本（类爆炸和继承大法）的实现方式，并不能适用于所有的子类。 这就需要一个新的设计思路。这里，我们将以饮料为主，然后运行的时候以饮料来“装饰”饮料。举个栗子，如果影虎需要摩卡和奶泡深焙咖啡，那么要做的是： 拿一个深焙咖啡（DarkRosat）对象 以摩卡（Mocha）对象装饰它 以奶泡（Whip）对象装饰它 调用cost（）方法，并依赖委托（delegate）将调料的价钱加上去。 具体的实现我们用一张图来展示 首先我们构建DarkRoast对象 假如顾客需要摩卡（Mocha），再建立一个Mocha对象，并用DarkRoast对象包起来。 如果顾客也想要奶泡（Whip）,就建立一个Whip装饰者，并将它用Mocha对象包起来。 最后运算客户的账单的时候，通过最外层的装饰者Whip的cost（）就可以办得到。Whip的cost（）会委托他的装饰对象（Mocha）计算出价格，再加上奶泡（Whip）的价格。 通过对星巴兹咖啡的设计方案分析，我们可以发现，所有的装饰类都具备以下几个特点： 装饰者和被装饰对象有相同的超类型。 你可以用一个或多个装饰者包装一个对象。 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它。 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象 什么是装饰模式呢？我们首先来看看装饰模式的定义： 装饰者模式动态地将责任附加到对象上。 若要扩展功能，装饰者提供了比继承更有弹性 的替代方案。 定义虽然已经定义了装饰者模式的“角色”，但是未说明怎么在我们的实现中如何使用它们。我们继续在星巴兹咖啡中来熟悉相关的操作。 其中装饰者层级可以无限发展下去，不是如图中一般两层关系。并且组件也并非只有一个，可以存在多个。 现在我们就在星巴兹咖啡里运用装饰者模式： 到这里，我们队装饰者模式已经有了一个基本的认识。那么我们已经解决了上面提到的四个问题： 第一，一旦调料的价格发生变化，会导致我们队原有代码进行大改。 第二，一旦出现新的调料，我们就需要加上新的方法，并需要改变超类Beverage类中cost（）方法。 第三，如果星巴兹咖啡研发新的饮料。对于这些饮料而言，某些调料可能并不合适，但是子类仍然会继承那些本就不合适的方法，例如我就想要一杯水，加奶泡（hasWhip）就不合适。 第四，如果用户需要双倍的摩卡咖啡，又应该怎么办呢？ 那么根据第四个问题，假如我们需要双倍摩卡豆浆奶泡拿铁咖啡时，该如何去运算账单呢？首先，我们先把前面的深度烘焙摩卡咖啡的设计图放在这里。 然后我们只需要将Mocha的装饰者加一，即可 实现星巴兹咖啡代码 前面已经把设计思想都设计出来了，接下来是将其具体实现了。首先从Beverage类下手 public abstract class Beverage1 { String description=\"Unknown Beverage\"; public String getDescription(){ return description; } public abstract double cost(); } Beverage类非常简单，然后再实现Condiment（调料类），该类为抽象类，也为装饰者类 public abstract class CondimentDecorator extends Beverage1{ //所有的调料装饰者都必须重新实现 getDescription()方法。 public abstract String getDescription(); } 前面已经有了饮料的基类，那么我们来实现一些具体的饮料类。首先从浓缩咖啡（Espresso））开始，这里需要重写cost()方法和getDescription（）方法 public class Espresso extends Beverage1{ public Espresso(){ //为了要设置饮料的描述，我 们写了一个构造器。记住， description实例变量继承自Beverage1 description=\"Espresso\"; } public double cost() { //最后，需要计算Espresso的价钱，现在不需要管调料的价钱，直接把Espresso的价格$1.99返回即可。 return 1.99; } } 再实现一个类似的饮料HouseBlend类。 public class HouseBlend extends Beverage1{ public HouseBlend(){ description=\"HouseBlend\"; } public double cost() { return 0.89; } } 重新设计DarkRoast1 public class DarkRoast1 extends Beverage1{ public DarkRoast1(){ description=\"DarkRoast1\"; } public double cost() { return 0.99; } } 接下来就是调料的代码，我们一开始已经实现了抽象组件类（Beverage），有了具体的组件（HouseBlend），也有了已经完成抽象装饰者（CondimentDecorator）。现在只需要实现具体的装饰者。首先我们先完成摩卡（Mocha） public class Mocha extends CondimentDecorator{ /** * 要让Mocha能够引用一个Beverage，采用以下做法 * 1.用一个实例记录饮料，也就是被装饰者 * 2.想办法让被装饰者（饮料）被记录在实例变量中。这里的做法是： * 把饮料当作构造器的参数，再由构造器将此饮料记录在实例变量中 */ Beverage1 beverage; public Mocha(Beverage1 beverage) { this.beverage=beverage; } public String getDescription() { //这里将调料也体现在相关参数中 return beverage.getDescription()+\",Mocha\"; } /** * 想要计算带摩卡的饮料的价格，需要调用委托给被装饰者，以计算价格， * 然后加上Mocha的价格，得到最终的结果。 */ public double cost() { return 0.21+beverage.cost(); } } 还有奶泡（Whip）类 public class Whip extends CondimentDecorator{ /** * 要让Whip能够引用一个Beverage，采用以下做法 * 1.用一个实例记录饮料，也就是被装饰者 * 2.想办法让被装饰者（饮料）被记录在实例变量中。这里的做法是： * 把饮料当作构造器的参数，再由构造器将此饮料记录在实例变量中 */ Beverage1 beverage; public Whip(Beverage1 beverage) { this.beverage=beverage; } public String getDescription() { //这里将调料也体现在相关参数中 return beverage.getDescription()+\",Whip\"; } /** * 想要计算带奶泡的饮料的价格，需要调用委托给被装饰者，以计算价格， * 然后加上Whip的价格，得到最终的结果。 */ public double cost() { return 0.22+beverage.cost(); } } 豆浆Soy类 public class Soy extends CondimentDecorator{ /** * 要让Soy能够引用一个Beverage，采用以下做法 * 1.用一个实例记录饮料，也就是被装饰者 * 2.想办法让被装饰者（饮料）被记录在实例变量中。这里的做法是： * 把饮料当作构造器的参数，再由构造器将此饮料记录在实例变量中 */ Beverage1 beverage; public Soy(Beverage1 beverage) { this.beverage=beverage; } public String getDescription() { //这里将调料也体现在相关参数中 return beverage.getDescription()+\",Soy\"; } /** * 想要计算带豆浆的饮料的价格，需要调用委托给被装饰者，以计算价格， * 然后加上Soy的价格，得到最终的结果。 */ public double cost() { return 0.21+beverage.cost(); } } 接下来就是调用测试类，具体实现如下： public class StarbuzzCoffe { public static void main(String[] args) { //订购一杯Espresso，不需要调料，打印他的价格和描述 Beverage1 beverage=new Espresso(); System.out.println(beverage.getDescription()+\"$\" +beverage.cost()); //开始装饰双倍摩卡+奶泡咖啡 Beverage1 beverage2=new DarkRoast1(); beverage2=new Mocha(beverage2); beverage2=new Mocha(beverage2); beverage2=new Whip(beverage2); System.out.println(beverage2.getDescription()+\"$\" +beverage2.cost()); // Beverage1 beverage3=new HouseBlend(); beverage3=new Soy(beverage3); beverage3=new Mocha(beverage3); beverage3=new Whip(beverage3); System.out.println(beverage3.getDescription()+\"$\" +beverage3.cost()); } } 运行结果： 到这里，我们已经完成装饰者模式对于星巴兹咖啡的改造。 Java中的真实装饰者 前面已经研究了装饰者模式的原理和实现方式，那么在JAVA语言本身是否有装饰者模式的使用范例呢，答案是肯定有的，那就是I/O流。 第一次查阅I/O源码，都会觉得类真多,而且一环嵌一环，阅读起来会非常麻烦。但是只要清楚I/O是根据装饰者模式设计，就很容易理解。我们先来看一下一个范例： 分析一下,其中BufferedInputStream及LineNumberInputStream都扩展自 FilterInputStream，而FilterInputStream是一个抽象的装饰类。这样看有些抽象，我们将其中的类按照装饰者模式进行结构化，方便理解。 我们发现，和星巴兹的设计相比，java.io其实并没有多大的差异。但是从java.io流我们也会发现装饰者模式一个非常严重的\"缺点\"：使用装饰者模式，常常会造成设计中有大量的小类，数量还非常多，这对于学习API的程序员来说就增加了学习难度和学习成本。但是，懂得装饰者模式以后会非常容易理解和设计相关的类。 设计自己的IO类 在理解装饰者模式和java.io的设计后，我们将磨炼下自己的熟悉程度，没错，就是自己设计一个Java I/O装饰者，需求如下： 编写一个装饰者，把输入流内的所有大写字符转成小写。举例：当读 取“ ASDFGHJKLQWERTYUIOPZXCVBNM”，装饰者会将它转成“ asdghjklqwertyuiopzxcvbnm”。具体的办法在于扩展FilterInputStream类，并覆盖read()方法就行了。 public class LowerCaseInputStream extends FilterInputStream{ public LowerCaseInputStream(InputStream inputStream){ super(inputStream); } public int read() throws IOException { int c=super.read(); //判断相关的字符是否为大写，并转为小写 return (c==-1?c:Character.toLowerCase((char)c)); } /** * *针对字符数组进行大写转小写操作 * @see java.io.FilterInputStream#read(byte[], int, int) */ public int read(byte[] b, int off, int len) throws IOException { int result=super.read(b,off,len); for(int i=off;i接下来我们构建测试类InputTest public class InputTest { public static void main(String[] args) { int c; try { InputStream inputStream=new LowerCaseInputStream(new BufferedInputStream(new FileInputStream(\"test.txt\"))); while((c=inputStream.read())>=0){ System.out.print((char)c); } } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 其中test.txt的内容可以自行编辑，放在项目根目录下我的内容原文为： 运行结果为： 5.总结 至此，我们已经掌握了装饰者模式的相关知识点。总结一下： 第五设计原则 类应该对拓展开放，对修改关闭。 装饰者模式动态地将责任附加到对象上。 若要扩展功能，装饰者提供了比继承更有弹性 的替代方案。 相应的资料和代码托管地址https://github.com/jixiang52002/HFDesignPattern Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-12 15:58:12 "},"Head-First-设计模式4------工厂方法模式.html":{"url":"Head-First-设计模式4------工厂方法模式.html","title":"Head-First-设计模式4----工厂方法模式","keywords":"","body":"本文参照《Head First 设计模式》，转载请注明出处 对于整个系列，我们按照这本书的设计逻辑，使用情景分析的方式来描述，并且穿插使用一些问题，总结的方式来讲述。并且所有的开发源码，都会托管到github上。 项目地址：https://github.com/jixiang52002/HFDesignPattern 回顾上一篇文章讲解了设计模式中常用的一种模式------装饰者模式。并结合星巴兹咖啡设计进行实战解析，并且从自己设计到JAVA自带设计模式做了讲解。想要了解的朋友可以回去回看一下。 本章将着重于在开发中最常遇到的初始化的问题，让你不会在new一个新的对象中感觉头疼。虽然本章取名是将工厂模式，但是这里会讲解两个设计模式，分别为工厂模式和抽象工厂设计模式。本章对于JAVA中抽象会大量运用到，未了解这方面的知识的朋友可以去查阅相关的资料。 1.前言 作为一个合格的JAVA开发程序员，我们知道要实例化一个类为对象，我们会利用类中的构造函数，使用new这个关键字。比如： Duck duck=new MallardDuck(); 这里使用接口的方式为的使代码具备弹性，但是如果我们需要根据属性值去赋值，比如下面这样的表达 Duck duck; if(picnic) { duck=new MallardDuck(); }else if (hunting) { duck=new DecoyDuck(); }else if (inBathTub) { duck=new RubberDuck(); } 这里对于Duck有一系列的实现类。但是具体使用哪一个类，却还需要通过属性条件来决定。 到这里，我们就可以提出问题：如果这部分属性发生很大的变化，甚至被取代掉了，是否我们对于这样受到影响的代码不都要做相关的操作？那这不就是违背了前面提到的一个概念解耦性。这段代码的耦合度就非常高。 那么问题来了：使用“new”到底有什么不对劲？（new大法简单粗暴啊，小姐姐最爱啊） 回答：前面提到一个概念“设计应该对拓展开放，对修改关闭”，new大法本身没有错误，毕竟JAVA最基础的组成架构。问题就是，这里的方式没做到拓展，也没有做到对修改闭环。 在开始说优化的方式之前，我们先来认识一下拓展和修改。 到这里，Duck将退出舞台 接下来，将由PIZZA上台 爱吃的吃货都不会陌生，生产一份披萨需要经过以下几个步骤： 准备（prepare） 烤制 （bake） 切片 （cut） 装盘 （box） 用代码来表示应该是如下步骤： public Pizza orderPizza() { Pizza pizza=new Pizza(); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } 但是我们知道PIZZA有很多种类，比如榴莲馅，奥尔良馅，芝士馅等，那为了能够适应这个需求，我们对于源代码需要更改： public Pizza orderPizza(String type) { Pizza pizza = null; if(type.equals(\"cheese\")) { pizza=new CheesePizza(); }else if (type.equals(\"greek\")) { pizza=new GreekPizza(); }else if (type.equals(\"pepperoni\")) { pizza=new PepperoniPizza(); } pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } 到这里就是熟悉的配方，熟悉的new大法，如果只有两三个类型都还好，但是如果有上万个类型选项呢，甚至可能由于CheesePizza卖的不是很好，我们需要将其去掉呢？是不是想要拓展或者修改，对于原有业务的修改会非常惊人。这时候，封装上马了。 2.封装 从前面分析，我们清楚需要将创建的代码从原有的业务中抽离出来。 首先，分析一下，其中准备到切片的过程是不变的（固定模块），是类型type不同会导致结果不同（拓展/修改模块）。所以我们将type初始化部分提取出来单独作为一个模块。 public class SimplePizzaFactory { /** * 所有的客户使用该方法来实例化对象 * @param type 类型 * @return PIZZA */ public Pizza createPizza(String type) { Pizza pizza=null; if(type.equals(\"cheese\")) { pizza=new CheesePizza(); }else if (type.equals(\"greek\")) { pizza=new GreekPizza(); }else if (type.equals(\"pepperoni\")) { pizza=new PepperoniPizza(); } return pizza; } } 这个用以实例化对象的类，我们称之为“工厂（factory）” question：这不就是把问题从一个地方移动到另一个地方了吗，问题依然存在。 answer:虽然是移动了，但是SimplePizzaFactory 可不仅仅只能为oderPizza提供对象初始化服务，还可以为其他对象服务。这里做一个比喻：一个业务部门（阿里支付部门）从公司分出成为分公司（蚂蚁金服），它既可以为原来的业务服务（淘宝,天猫），也可以为新的业务服务（移动支付，企业服务）。 question:将工厂方法定义为静态方法有什么好处和坏处？ answer:利用静态方法定义一个简单的工厂模式，最为常见（不一定是Factory类），常称为静态工厂。 好处：不需要实例化对象，不占据多少内存 坏处：无法通过继承来改变内部的实现方法 按照简单工厂我们可以修改自己的代码 public class PizzaStore { SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) { this.factory=factory; } /** * 根据类型生成PIZZA * @param type * @return PIZZA */ public Pizza orderPizza(String type) { Pizza pizza; //orderPizza通过传入type类型，使用工厂完成创建 pizza=factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } } 3.简单工厂（非设计模式） 简单工厂其实严格意义上不是设计模式，而是一种编程习惯，还是最常用的那种。。。。（哎，你别动手） （屈服于大佬的淫威）但是呢，并不能说它不是一种设计模式就不重视它，从前面的PIZZA类图分析： 其实这时候，我们已经接近了设计模式。所以接下来，就是最重要的设计模式。 4.新业务需求：加盟店模式 由于经营合理加上口味独特，PIZZA店终于大获成功。现在所有的消费者和餐饮投资人都希望在自己的附近能够有一家加盟店。作为经营者，你可以按照以下两种模式来选择加盟方式： 所有加盟店使用与总店一起使用相同的配方（直营店模式） 每家加盟店可以根据当地风味的不同，自己更改其中的配方和风味（加盟商模式） 从现在做的比较大的必胜客，肯德基，麦当劳的经营模式来看，后者会让经营模式更加灵活。但是前者可以保证加盟店的产品质量和口碑，比如京东线下店，苏宁易购等。所以我们来看看不同的加盟模式，会对原有的业务需求造成什么影响。4.1 直营店模式 首先是设计结构，PizzaStore 所以这里我们需要拓展SimplePizzaFactory，这里需要类似于NYPizzaFactory、ChicagoPizzaFactory、ChinaPizzaFactory（甚至可以再细分)，那么准备一份Pizza的流程就需要更改 NYPizzaFactory factory=new NYPizzaFactory(); PizzaStore nyStore=new PizzaStore(); nyStore.oderPizza(\"Veggie\"); 相对来说就非常简单。那么如果是加盟商模式呢 4.2 加盟商模式 在某些加盟商里有一些经验很丰富的厨师，他们在做Pizza的时候，会加入自己的一些思路和想法，比如： 过量的芝士，本地风味的榴莲，甚至可能存在双拼的情况。但是我们知道，我们在一开始是将这些操作放在SimplePizzaFactory里，这就使得代码结构不具备活性。就是前面提到的，拓展和修改方面不满足需求。 那么，如何修改现有的结构可以满足需求呢？ 按照前面的经验：尽量拓展，少修改。我们发现有区别的地方在于各地的PizzaStore不同，那么是否可以在PizzaStore这里做拓展呢。 这里可以尝试把createPizza放回PizzaStore类里面，但是不需要具体方法体，使用抽象类和抽象方法。让具体的PizzaStore去实现具体的createPizza方法。看一下修改后的效果： public abstract class AbstactPizzaStore { /** * 根据类型生成PIZZA * @param type * @return PIZZA */ public Pizza orderPizza(String type) { Pizza pizza; //orderPizza通过传入type类型，使用工厂完成创建 pizza=createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } /** * 工厂对象功能移到这里 * @param type * @return PIZZA */ abstract Pizza createPizza(String type); } 这里有了超类AbstractPizzaStore，就可以实现NYPizzaStore、ChicagoPizzaStore、ChinaPizzaStore等。 这里这些子类就具备决定权。 public class NYPizzaStore extends AbstactPizzaStore { @Override public Pizza createPizza(String type) { Pizza pizza=null; if(type.equals(\"cheese\")) { pizza=new NYStyleCheesePizza(); }else if (type.equals(\"greek\")) { pizza=new NYStyleGreekPizza(); }else if (type.equals(\"pepperoni\")) { pizza=new NYStylePepperoniPizza(); } return pizza; } } 分析：为何这样做会更好，好处就在于，PizzaStore的oderPizza不需要关注createPizza的Pizza是怎么来的。它只知道createPizza返回的Pizza可以做后续操作。这种对于其他业务有哪些类参与进来的方法，我们称为解耦。 而这个抽象方法我们称为工厂方法，就是实现了工厂类效果的抽象方法。 /* 工厂对象功能移到这里 * @param type * @return PIZZA */ abstract Pizza createPizza(String type); 工厂方法必须具备以下几个条件： 工厂方法是抽象的，依赖子类来处理具体逻辑 工厂方法必须返回一个产品对象，通常定义在返回值（也可以使用回调） 工厂方法需要将修改部分从稳定部分中抽离出来。 工厂方法中必须有创建者类（稳定部分）和产品类（修改部分） 到这里，就完成了加盟店的设计。 5.工厂方法模式 从前面我们认识了工厂方法，那么到这里就可以推出我们第一个工厂模式------工厂方法模式。 工厂方法模式定义了一个创建对象的接口，但是由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 抽象结构如下： Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-12 15:58:12 "},"javaweb/学习路径.html":{"url":"javaweb/学习路径.html","title":"学习路径","keywords":"","body":" Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-05-06 19:25:58 "},"javaweb/环境配置.html":{"url":"javaweb/环境配置.html","title":"环境搭建","keywords":"","body":"环境变量配置 1、java环境变量配置 1.1 Windows环境下 现在orcle官网下载JDK 点击这里，下载对应版本的jdk，运行后完成安装，找到安装路径： C:\\Program Files\\Java\\jdk1.8.0_201\\bin 我们需要把这个路径配置到系统环境变量中去 首先打开系统环境变量的目录：我的电脑-属性-高级系统设置-环境变量 配置JAVA_HOME(idea中会用到) 配置path环境变量 完成后打开命令行，使用java -version 若是有版本号出现，那么JDK环境配置成功 1.2 Mac环境下 现在orcle官网下载JDK 点击这里，下载对应版本的jdk，运行后完成安装 由于mac在安装完成后自动会配置环境变量，不需要手动配置。使用命令行检测环境变量java -version 若是有版本出现，那么JDK环境配置成功 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 14:52:57 "},"javaweb/maven.html":{"url":"javaweb/maven.html","title":"maven","keywords":"","body":"Maven 1、maven相关主要内容 maven的简介 maven的安装配置和目录结构 idea编辑器集成Maven环境 maven项目的创建 maven仓库的基本概念 maven环境下构建多模块项目 maven的打包操作 maven依赖的基本概念 2.Maven的简介 Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。 2.1项目构建工具 Ant构建 Maven（java） Gradle：Android御用的，结合了ant和Maven的特点，采取了DSL格式 2.2Maven的四大特性 依赖管理系统 3.Maven的结构目录 a-maven-project ├── pom.xml ├── src │ ├── main │ │ ├── java │ │ └── resources │ └── test │ ├── java │ └── resources └── target 解释一下：a-maven-project为项目名；pom.xml为项目描述文件,ser/main/java 为源码目录，src/main/resources 为资源目录，src/test/java存放测试源码目录，src/test/resources存放测试资源，最终所有的编译、打包生成文件都放在target目录里。这些就是一个maven项目标准的目录结构 porm.xml文件格式 4.0.0 com.itranswarp.learnjava hello 1.0 jar ... commons-logging commons-logging 1.2 modelversion 指定当前的pom模型的版本，对于Maven3来说只能是4.0.0 groupId类似于Java的包名，通常是公司或组织名称，指定了项目属于哪一个组织 artifactId类似于Java的类名，通常是项目名称，定义了项目在组织中的唯一的ID version指定当前包的版本号，x.x.x-里程碑；如1.0.0-SNAPSHOT；其中第一个x 为大版本，在有大变动时升级；第二个x小版本 修复bug，增加功能时使用；第三个x 为开发更新版本 总结：一个Maven工程就是由groupId，artifactId和version作为唯一标识。 一个标准的dependency标准 commons-logging commons-logging 1.2 4.安装Maven 4.1 下载maven并完成环境变量配置 1.在官网下载对应的maven版本 2.配置环境变量 MAVEN_HOME ,path 3.命令行检测是否配置成功 mvn -version 4.2 修改本地仓库配置 这里还需要更改一下setting.xml下的配置，用来提升使用效率 Question：为什么需要修改本地maven仓库呢？ answer;因为 Maven 默认的本地仓库在C/用户/.m2 文件夹里，随着下载的 jar 包越来越多，系统盘会越来越满，电脑会越来越卡，所以建议在 C 盘之外建一个本地仓库。 1.新建一个目录 2.打开maven下setting.xml文件修改核心配置文件 3.需要添加的标签如下： respository 地址 你的repository目录 例如：D:\\CodeSoftware\\Maven\\repository 4.配置阿里云镜像下载地址 在 setting.xml 文件里面添加： alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/; central 因为国外远程仓库下载 jar 包速度慢，国内阿里云下载速度快 最后贴一下完整的setting.xml D:\\CodeSoftware\\maven\\repository alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central 5.依赖管理 ┌──────────────┐ │Sample Project│ └──────────────┘ │ ▼ ┌──────────────┐ │ abc │ └──────────────┘ │ ▼ ┌──────────────┐ │ xyz │ └──────────────┘ Q：如上面所描述的，如果项目依赖了abc库，而abc库又依赖了xyz库，那么是否在项目中需要在申请abc库的同时又申请xyz库吗？ answer：在maven环境下不需要，当已经配置abc的依赖时，xyz会一起被依赖 5.1依赖关系 Maven定义了几种依赖关系，分别是compile、test、runtime和provided： scope 说明 示例 compile 编译时需要用到该jar包（默认） commons-logging test 编译Test时需要用到该jar包 junit runtime 编译时不需要，但运行时需要用到 mysql provided 编译时需要用到，但运行时由JDK或某个服务器提供 servlet-api compile是最常用的，Maven会把这种类型的依赖直接放入classpath中 test依赖表示仅在测试时使用，正常运行时并不需要 runtime依赖表示编译时不需要，但运行时需要 provided依赖表示编译时需要，但运行时不需要。 Q:maven从哪里下载所需依赖？ Answer：https://repo1.maven.org/ 这个是maven的中心仓库，然后将所有的第三发库和自身的jar库托管在中央仓库，本地仓库（前面配置的地址，若没有，就在用户目录的 .m目录下）只要下载一次，下次使用可直接使用本地仓库。 5.2唯一ID 那么是如何定位一个依赖的 groupId：属于组织的名称，类似Java的包名； artifactId：该jar包自身的名称，类似Java的类名； version：该jar包的版本。 Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。 5.3镜像仓库 由于maven中央仓库在外网上，所以下载速度会很慢，我们还可以配置镜像仓库加速依赖构建 slow ┌───────────────────┐ ┌─────────────>│Maven Central Repo.│ │ └───────────────────┘ │ │ │ │sync │ ▼ ┌───────┐ fast ┌───────────────────┐ │ User │─────────>│Maven Mirror Repo. │ └───────┘ └───────────────────┘ 上面为配置镜像后的依赖路径 aliyun aliyun central https://maven.aliyun.com/repository/central 上面为阿里云的镜像maven仓库 5.4 如何寻找第三方库 1.https://search.maven.org/ 好用就是每次都需要人机校验 2、https://u.tools/ utools 一个工具非常好用，加载maven插件很好用 其他工具 5.5 常用命令行 本地发布 mvn clean install -DskipTests 平台发布 mvn clean deploy -Dmaven.test.skip 命令行编译 mvn clean package 其中-D 传入属性参数 例如：mvn package -Dmaven.test.skip=true 其中maven.test.skip代表跳过是否跳过单元测试 其中-P使用指定的Profile配置 6.maven构建流程 Maven的生命周期(lifecycle）由一系列阶段（phase）构成，以内置的生命周期default为例，它具备以下phase： validate initialize generate-sources process-sources generate-resources process-resources compile process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile process-test-classes test prepare-package package pre-integration-test integration-test post-integration-test verify install deploy 例如，运行 mvn package,maven执行顺序如下 validate ... package 运行mvn compile,maven执行顺序如下 validate ... compile maven另一个声明周期是clean pre-clean clean （注意这个clean不是lifecycle而是phase） post-clean 更高级的例子是同时使用多个phase，例如：mvn clean package; Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下： pre-clean clean （注意这个clean是phase） validate ... package 6.1常用的命令 mvn clean：清理所有生成的class和jar； mvn clean compile：先清理，再执行到compile； mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile； mvn clean package：先清理，再执行到package。 6.2 Goal 执行一个phase又会触发一个或多个goal： 执行的Phase 对应执行的Goal compile compiler:compile test compiler:testCompile surefire:test goal的命名总是abc:xyz这种形式。 总结 lifecycle相当于Java的package，它包含一个或多个phase； phase相当于Java的class，它包含一个或多个goal； goal相当于class的method，它其实才是真正干活的。 7.Maven插件 自定义插件 ... org.apache.maven.plugins maven-shade-plugin 3.2.1 package shade ... 自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定Java程序的入口，它的配置是： com.itranswarp.learnjava.Main tips:Maven自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明 常用的插件： maven-shade-plugin：打包所有依赖包并生成可执行jar； cobertura-maven-plugin：生成单元测试覆盖率报告； findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。 8.模块管理 在软件开发中，经常把一个较大项目拆分成多个模块，用来降低软件的复杂度 ┌─────────┐ │ │Module A │ │ └─────────┘ ┌──────────────┐ split │ ┌─────────┐ │ │Single Project│───────> │Module B │ └──────────────┘ │ └─────────┘ │ ┌─────────┐ │ │Module C │ │ └─────────┘ └ ─ ─ ─ ─ ─ ─ ┘ 上面这个结构的项目就可以被拆分成一下结构： 原始结构 single-project ├── pom.xml └── src 拆分后的结构 mutiple-project ├── module-a │ ├── pom.xml │ └── src ├── module-b │ ├── pom.xml │ └── src └── module-c ├── pom.xml └── src 这里可以使用Maven管理多个模块，我们只需要把每个模块当做一个独立的Maven项目，它们有各自独立的pom.xml。例如module A： 4.0.0 com.itranswarp.learnjava module-a 1.0 jar module-a UTF-8 UTF-8 11 11 11 org.slf4j slf4j-api 1.7.28 ch.qos.logback logback-classic 1.2.3 runtime org.junit.jupiter junit-jupiter-engine 5.5.2 test module B的 4.0.0 com.itranswarp.learnjava module-b 1.0 jar module-b UTF-8 UTF-8 11 11 11 org.slf4j slf4j-api 1.7.28 ch.qos.logback logback-classic 1.2.3 runtime org.junit.jupiter junit-jupiter-engine 5.5.2 test 如果在A和B中存在共同的部分作为parent 4.0.0 com.itranswarp.learnjava parent 1.0 pom parent UTF-8 UTF-8 11 11 11 org.slf4j slf4j-api 1.7.28 ch.qos.logback logback-classic 1.2.3 runtime org.junit.jupiter junit-jupiter-engine 5.5.2 test 这样修改后的项目结构为 multiple-project ├── pom.xml ├── parent │ └── pom.xml ├── module-a │ ├── pom.xml │ └── src ├── module-b │ ├── pom.xml │ └── src └── module-c ├── pom.xml └── src 这样module A可以简化为 4.0.0 com.itranswarp.learnjava parent 1.0 ../parent/pom.xml module-a jar module-a 如果module A 依赖module B，那么module A需要module B的jar包才能正常编译，我们需要在module A中引入 module B ... com.itranswarp.learnjava module-b 1.0 在根目录创建一个pom.xml统一编译 4.0.0 com.itranswarp.learnjava build 1.0 pom build parent module-a module-b module-c 这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个，一次性全部编译。 8.1 中央仓库 其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。 8.2 私有仓库 私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。 8.3 本地仓库 本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。 9.使用mvnw 一般情况maven使用mvn这一个命令。但是其实还有一个命令行mvnw mvnw是Maven Wrapper的缩写。因为我们安装maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。 简单地说，Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。 9.1 安装Maven Wrapper 安装Maven Wrapper最简单的方式是在项目的根目录（即pom.xml所在的目录）下运行安装命令： mvn -N io.takari:maven:0.7.6:wrapper 果要指定使用的Maven版本，使用下面的安装命令指定版本，例如3.3.3： mvn -N io.takari:maven:0.7.6:wrapper -Dmaven=3.3.3 安装后，查看项目结构： my-project ├── .mvn │ └── wrapper │ ├── MavenWrapperDownloader.java │ ├── maven-wrapper.jar │ └── maven-wrapper.properties ├── mvnw ├── mvnw.cmd ├── pom.xml └── src ├── main │ ├── java │ └── resources └── test ├── java └── resources 发现多了mvnw、mvnw.cmd和.mvn目录，我们只需要把mvn命令改成mvnw就可以使用跟项目关联的Maven。例如： mvnw clean package 在Linux或macOs下运行时需要加上./ ./mvnw clean package Maven Wrapper的另一个作用是把项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可以使所有开发人员使用统一的Maven版本。 10.发布自己Artifact 这一章解决了一个问题;那么问题来了：当我们自己写了一个牛逼的开源库时，非常希望别人也能使用，总不能直接放个jar包的链接让别人下载吧？(也不知道有木有) 把自己的库发布到Maven的repo中有好几种方法，我们介绍3种最常用的方法。 10.1 以静态文件发布 实例：开源项目how-to-become-rich 工程目录 how-to-become-rich ├── maven-repo pom.xml中添加如下内容： ... local-repo-release GitHub Release file://${project.basedir}/maven-repo maven-source-plugin attach-sources package jar-no-fork maven-javadoc-plugin attach-javadocs package jar 打包命令行 mvn clean package deploy 如果一切顺利，我们就可以在maven-repo目录下找到部署后的所有文件如下： maven-repo └── com └── itranswarp └── rich └── how-to-become-rich ├── 1.0.0 │ ├── how-to-become-rich-1.0.0-javadoc.jar │ ├── how-to-become-rich-1.0.0-javadoc.jar.md5 │ ├── how-to-become-rich-1.0.0-javadoc.jar.sha1 │ ├── how-to-become-rich-1.0.0-sources.jar │ ├── how-to-become-rich-1.0.0-sources.jar.md5 │ ├── how-to-become-rich-1.0.0-sources.jar.sha1 │ ├── how-to-become-rich-1.0.0.jar │ ├── how-to-become-rich-1.0.0.jar.md5 │ ├── how-to-become-rich-1.0.0.jar.sha1 │ ├── how-to-become-rich-1.0.0.pom │ ├── how-to-become-rich-1.0.0.pom.md5 │ └── how-to-become-rich-1.0.0.pom.sha1 ├── maven-metadata.xml ├── maven-metadata.xml.md5 └── maven-metadata.xml.sha1 最后一步，是把这个工程推到GitHub上，并选择Settings-GitHub Pages，选择master branch启用Pages服务： 这样，把全部内容推送至GitHub后，即可作为静态网站访问Maven的repo，它的地址是https://michaelliao.github.io/how-to-become-rich/maven-repo/。版本`1.0.0`对应的jar包地址是： https://michaelliao.github.io/how-to-become-rich/maven-repo/com/itranswarp/rich/how-to-become-rich/1.0.0/how-to-become-rich-1.0.0.jar 其他人使用maven包的方式 com.itranswarp.rich how-to-become-rich 1.0.0 与此同时我们需要添加一个的声明 4.0.0 example how-to-become-rich-usage 1.0-SNAPSHOT jar 11 11 11 github-rich-repo The Maven Repository on Github https://michaelliao.github.io/how-to-become-rich/maven-repo/ com.itranswarp.rich how-to-become-rich 1.0.0 10.2 通过Nexus发布到中央仓库 我们不能直接发布到Maven中央仓库，而是通过曲线救国的方式，发布到central.sonatype.org，它会定期自动同步到Maven的中央仓库。Nexus是一个支持Maven仓库的软件，由Sonatype开发，有免费版和专业版两个版本，很多大公司内部都使用Nexus作为自己的私有Maven仓库，而这个central.sonatype.org相当于面向开源的一个Nexus公共服务 第一步是在central.sonatype.org上注册一个账号，注册链接非常隐蔽，可以自己先找找，找半小时没找到点这里)查看攻略。 这里简单提一下发布重点与难点： 必须正确创建GPG签名，Linux和Mac下推荐使用gnupg2； 必须在~/.m2/settings.xml中配置好登录用户名和口令，以及GPG口令： ... ossrh OSSRH-USERNAME OSSRH-PASSWORD ossrh true gpg2 GPG-PASSWORD 在待发布的Artifact的pom.xml中添加OSS的Maven repo地址，以及maven-jar-plugin、maven-source-plugin、maven-javadoc-plugin、maven-gpg-plugin、nexus-staging-maven-plugin： ... ossrh https://oss.sonatype.org/content/repositories/snapshots ossrh Nexus Release Repository http://oss.sonatype.org/service/local/staging/deploy/maven2/ org.apache.maven.plugins maven-jar-plugin jar test-jar org.apache.maven.plugins maven-source-plugin attach-sources jar-no-fork org.apache.maven.plugins maven-javadoc-plugin attach-javadocs jar -Xdoclint:none org.apache.maven.plugins maven-gpg-plugin sign-artifacts verify sign org.sonatype.plugins nexus-staging-maven-plugin 1.6.3 true ossrh https://oss.sonatype.org/ true 最后执行命令 mvn clean package deploy 完成发布 10.3 发布到私有仓库 通过nexus-staging-maven-plugin除了可以发布到central.sonatype.org外，也可以发布到私有仓库，例如，公司内部自己搭建的Nexus服务器。 如果没有私有Nexus服务器，还可以发布到GitHub Packages。GitHub Packages是GitHub提供的仓库服务，支持Maven、NPM、Docker等。使用GitHub Packages时，无论是发布Artifact，还是引用已发布的Artifact，都需要明确的授权Token，因此，GitHub Packages只能作为私有仓库使用。 在发布前，我们必须首先登录后在用户的Settings-Developer settings-Personal access tokens中创建两个Token，一个用于发布，一个用于使用。发布Artifact的Token必须有repo、write:packages和read:packages权限： 在发布端，把GitHub的用户名和发布Token写入~/.m2/settings.xml配置中： ... github-release GITHUB-USERNAME f052...c21f 然后，在需要发布的Artifact的pom.xml中，添加一个声明： ... github-release GitHub Release https://maven.pkg.github.com/michaelliao/complex 注意到和~/.m2/settings.xml配置中的要保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能成功上传文件到GitHub。我们直接通过命令mvn clean package deploy部署，成功后，在GitHub用户页面可以看到该Artifact： 使用该Artifact时，因为GitHub的Package只能作为私有仓库使用，所以除了在使用方的pom.xml中声明外： ... github-release GitHub Release https://maven.pkg.github.com/michaelliao/complex com.itranswarp complex 1.0.0 ... 还需要把有读权限的Token配置到~/.m2/settings.xml文件中。 11.idea 集成maven环境 11.1 配置maven 11.2 创建maven项目 11.2.1 java项目 设置groupid和artifactid 如何配置编译？ 选择指令和编译的目录 也可以用右侧的maven plugin 11.2.2 创建web项目 其他配置和java项目一样 补充：Tomcat配置 先下载Tomcat，完成安装，并启动 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-12 15:58:13 "},"javaweb/MySQL学习.html":{"url":"javaweb/MySQL学习.html","title":"Mysql学习","keywords":"","body":"MySQl(老杜) 1.初识MySQL Q：什么是数据库？什么是数据库管理系统？什么是SQL？ 数据库： 英文单词：database，简称DB。按照一定格式存储数据的一些文件组合。顾名思义，存储数据的仓库，实际上就是一堆文件，这些文件存储了具有特定格式的数据 数据库管理 DataBaseManagement:简称DMBMS 数据库管理系统术专门用来管理数据库汇总的数据的，数据库管理系统可以对数据库中的数据进行增删改查 常见的数据库管理系统：Mysql、Orcle、Ms SqlServer、DB2等 SQL:结构化查询语言 程序员需要学习SQL语句，实现增删改查 三者关系：DMBMS->执行->SQL->操作->DB 2.安装Mysql 网路教程即可，傻瓜式安装 2.1 配置环境变量 Windows配置方式与Java环境配置相同； mac 配置环境变量 未配置时的状态 切换到zsh命令（新的mac系统大部分是这个命令行） chsh -s /bin/zsh 首先配置环境变量文件 vim ~/.zshrc 在打开的文件里追加以下内容 export PATH=$PATH:/usr/local/mysql/bin alias mysqlstart='sudo /usr/local/mysql/support-files/mysql.server start' alias mysqlstop='sudo /usr/local/mysql/support-files/mysql.server stop' 之后，按esc退出插入模式，并输入:wq ( 有:哦 ) 使用vim命令保存文件内容 source ~/.zshrc 查看是否成功 echo $PATH 如果添加成功，会出现/usr/local/mysql/bin这一句，就说明配置成功了 需要注意端口不可以冲突 3.数据库常用命令行 登录数据库 mysql -uroot -p [密码] 退出数据库 exit 查看mysql中有哪些数据库 show databases; 这四个是默认数据库 打开指定的数据库 use [数据库名字]; 创建数据库 create database [数据库名]; 4.表常用命令行 表：数据中最基本的单位table，数据库中是以表格的形式来表示数据的，任何一张表都有行和列 行：row，被称为数据或记录 列：column，被称为字段 ps：每一个字段都有：字段名、数据类型、约束等属性 字段名：见名知意 数据类型：字符串，数字，日期等 约束：被约束的字段具备唯一性 查看表 show tables; 查看mysql数据库的版本号 select verison(); 查看当前使用的是哪个数据库 select database(); 注意：\\c用来终止一条命令的输入。 5.常用SQL语句的分类 DQL：数据查询语言 (DQL-Data Query Language) 凡是带有select关键字的都是查询语句 DML：数据操作语言 (DML-Data Manipulation Language) 凡是对表当中的数据进行增删改的都是DML insert 增 delete 删 update 改 注意：这个主要是操作表中的数据data。 DDL：数据定义语言 (DDL-Data Definition Language) DDL主要操作的是表的结构，不是表中的数据。 create：新建，等同于增 drop：删除 alter：修改 注意：这个增删改和DML不同，这个主要是对表结构进行操作。 TCL：事务控制语言 (TCL-Transactional Control Language) ​ 事务提交：commit; ​ 事务回滚：rollback, DCL：是数据控制语言 (DCL-Data Control Language) 授权：grant 撤销权限：revoke 6.导入准备的表 导入sql文件 resource [sql路径名] 注意：路径中不要有中文！！！！这里使用到的资源https://pan.baidu.com/share/init?surl=kW7V3yLaxDJxCaZ2yp019g 密码：y346 最终表如下 其中：DEPT 部门表 EMP员工表 SALGRADE 工资等级表 删除表（这里不建议测试） drop database [表名] 查看表中所有数据 select * from 表名; 不看表中的数据，只看表的结构 desc 表名; 效果如下： 7.查询操作 7.1 普通查询方式 查询表中某几个字段 select [字段，中间用“,”隔开] from 【表名】 mysql> select deptno,dname from dept; +--------+------------+ | deptno | dname | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+ 4 rows in set (0.00 sec) 查询全部字段 #第一种方式：可以把每个字段都写上 select a,b,c,d,e,f… from tablename; #第二种方式：可以使用* select * from tablename; 注意：这种方式的缺点： 1、效率低 2、可读性差。 在实际开发中不建议，可以自己玩没问题。 你可以在DOS命令窗口中想快速的看一看全表数据可以采用这种方式。 给查询的类起别名 select deptno,dname as deptname from dept; +--------+------------+ | deptno | deptname | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+ 4 rows in set (0.00 sec) 其中as 为起别名的关键字 注意：只是将显示的查询结果列名显示为deptname，原表列名还是叫：dname 记住：select语句是永远都不会进行修改操作的。（因为只负责查询） 并且，as关键字是可以被省略的 mysql> select deptno,dname deptname from dept; +--------+------------+ | deptno | deptname | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+ 4 rows in set (0.00 sec) Q:如果别名里面有空格该如何处理？ select deptno,dname 'dept name' from dept; //加单引号 select deptno,dname \"dept name\" from dept; //加双引号 +--------+------------+ | deptno | dept name | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+ 注意： 在所有的数据库当中，字符串统一使用单引号括起来， 单引号是标准，双引号在oracle数据库中用不了。但是在mysql中可以使用。 查询中带公式 mysql> select ename,sal*12 as yearsal from emp; +--------+----------+ | ename | yearsal | +--------+----------+ | SMITH | 9600.00 | | ALLEN | 19200.00 | | WARD | 15000.00 | | JONES | 35700.00 | | MARTIN | 15000.00 | | BLAKE | 34200.00 | | CLARK | 29400.00 | | SCOTT | 36000.00 | | KING | 60000.00 | | TURNER | 18000.00 | | ADAMS | 13200.00 | | JAMES | 11400.00 | | FORD | 36000.00 | | MILLER | 15600.00 | +--------+----------+ 14 rows in set (0.00 sec) ## 别名为中文，需要带 ‘’ +--------+----------+ | ename | 年薪 | +--------+----------+ | SMITH | 9600.00 | | ALLEN | 19200.00 | | WARD | 15000.00 | | JONES | 35700.00 | | MARTIN | 15000.00 | | BLAKE | 34200.00 | | CLARK | 29400.00 | | SCOTT | 36000.00 | | KING | 60000.00 | | TURNER | 18000.00 | | ADAMS | 13200.00 | | JAMES | 11400.00 | | FORD | 36000.00 | | MILLER | 15600.00 | +--------+----------+ 14 rows in set (0.00 sec) 7.2条件查询 运算符 说明 = 等于 <>或者!=bu 不等于 小于 小于等于 > 大于 >= 大于等于 between ... and ... 在两个值之间 is null 为空 and 并且 or 或者 in 包含 not 非 like 模糊查询支持%或_,其中%匹配任意长的字符，一个_匹配一个字符 关键字where具体的语法格式如下 select 字段1,字段2,字段3… from 表名 where 条件; =等于 查询薪资等于800的员工姓名和编号： mysql> select empno,ename from emp where sal = 800; +-------+-------+ | empno | ename | +-------+-------+ | 7369 | SMITH | +-------+-------+ 1 row in set (0.00 sec) 查询SMITH的编号和薪资 mysql> select empno,sal from emp where ename = 'SMITH' ; +-------+--------+ | empno | sal | +-------+--------+ | 7369 | 800.00 | +-------+--------+ 1 row in set (0.00 sec) <>!=不等于 薪资不是800的员工编号和姓名 mysql> select empno,ename from emp where sal !=800; +-------+--------+ | empno | ename | +-------+--------+ | 7499 | ALLEN | | 7521 | WARD | | 7566 | JONES | | 7654 | MARTIN | | 7698 | BLAKE | | 7782 | CLARK | | 7788 | SCOTT | | 7839 | KING | | 7844 | TURNER | | 7876 | ADAMS | | 7900 | JAMES | | 7902 | FORD | | 7934 | MILLER | +-------+--------+ 13 rows in set (0.00 sec) # 与上面效果一样 mysql> select empno,ename from emp where sal <>800; +-------+--------+ | empno | ename | +-------+--------+ | 7499 | ALLEN | | 7521 | WARD | | 7566 | JONES | | 7654 | MARTIN | | 7698 | BLAKE | | 7782 | CLARK | | 7788 | SCOTT | | 7839 | KING | | 7844 | TURNER | | 7876 | ADAMS | | 7900 | JAMES | | 7902 | FORD | | 7934 | MILLER | +-------+--------+ 13 rows in set (0.00 sec) between ... and ... 两个值之间，等于 >= and 查询薪资在2450和3000之间的员工信息，包括2450和3000 mysql> select empno,ename,sal from emp where sal>=2450 and sal select empno,ename,sal from emp where sal between 2450 and 3000; +-------+-------+---------+ | empno | ename | sal | +-------+-------+---------+ | 7566 | JONES | 2975.00 | | 7698 | BLAKE | 2850.00 | | 7782 | CLARK | 2450.00 | | 7788 | SCOTT | 3000.00 | | 7902 | FORD | 3000.00 | +-------+-------+---------+ 5 rows in set (0.00 sec) 注意：betwwen and 必须遵循左小右大，between and 是闭区间，包括两端的值。 is null 为 null（is not null 不为空） 查询补助为null的员工 mysql> select empno,ename,sal,comm from emp where comm is null; +-------+--------+---------+------+ | empno | ename | sal | comm | +-------+--------+---------+------+ | 7369 | SMITH | 800.00 | NULL | | 7566 | JONES | 2975.00 | NULL | | 7698 | BLAKE | 2850.00 | NULL | | 7782 | CLARK | 2450.00 | NULL | | 7788 | SCOTT | 3000.00 | NULL | | 7839 | KING | 5000.00 | NULL | | 7876 | ADAMS | 1100.00 | NULL | | 7900 | JAMES | 950.00 | NULL | | 7902 | FORD | 3000.00 | NULL | | 7934 | MILLER | 1300.00 | NULL | +-------+--------+---------+------+ 10 rows in set (0.00 sec) 查询补助不为null的员工 mysql> select empno,ename,sal,comm from emp where comm is not null; +-------+--------+---------+---------+ | empno | ename | sal | comm | +-------+--------+---------+---------+ | 7499 | ALLEN | 1600.00 | 300.00 | | 7521 | WARD | 1250.00 | 500.00 | | 7654 | MARTIN | 1250.00 | 1400.00 | | 7844 | TURNER | 1500.00 | 0.00 | +-------+--------+---------+---------+ 4 rows in set (0.00 sec) and 并且（多条件结合） 查询工作岗位是MANAGER 并且工资大于2500的员工 mysql> select empno,job from emp where job = 'MANAGER' and sal>2500; +-------+---------+ | empno | job | +-------+---------+ | 7566 | MANAGER | | 7698 | MANAGER | +-------+---------+ 2 rows in set (0.00 sec) or 或者（两者满足其一即可） 查询工作岗位是MANAGER或SALESMAN的员工 mysql> select empno,job from emp where job = 'MANAGER' or job='SALESMAN'; +-------+----------+ | empno | job | +-------+----------+ | 7499 | SALESMAN | | 7521 | SALESMAN | | 7566 | MANAGER | | 7654 | SALESMAN | | 7698 | MANAGER | | 7782 | MANAGER | | 7844 | SALESMAN | +-------+----------+ 7 rows in set (0.00 sec) and和or同时出现，要考虑优先级到的问题 查询工资大于2500，并且部门编号为10或20部门的员工 mysql> select * from emp where sal > 2500 and (deptno = 10 or deptno = 20); +-------+-------+-----------+------+------------+---------+------+--------+ | EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO | +-------+-------+-----------+------+------------+---------+------+--------+ | 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 | | 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 | | 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 | | 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 | +-------+-------+-----------+------+------------+---------+------+--------+ 4 rows in set (0.00 sec) 注意：and 和or同时出现，and优先级高。如果想让or先执行，需要加括号。以后开发中，如果不确定优先级，就加括号。 in 包含，相当于多个 or（not in 不在这个范围中） 查询工作岗位是MANAGER和SALESMAN的员工： select empno,ename,job from emp where job = 'MANAGER' or job = 'SALESMAN'; select empno,ename,job from emp where job in('MANAGER', 'SALESMAN'); 上面两个查询语句是一样的效果 注意：in不是一个区间，in后面跟的是具体的值。 查询薪资是800和5000的员工信息： mysql> select ename,sal from emp where sal in(800,5000); +-------+---------+ | ename | sal | +-------+---------+ | SMITH | 800.00 | | KING | 5000.00 | +-------+---------+ 2 rows in set (0.00 sec) not 可以取非，主要用在is或in中 is null、is not null、in、not in mysql> select ename,sal from emp where sal not in(800,5000,3000); +--------+---------+ | ename | sal | +--------+---------+ | ALLEN | 1600.00 | | WARD | 1250.00 | | JONES | 2975.00 | | MARTIN | 1250.00 | | BLAKE | 2850.00 | | CLARK | 2450.00 | | TURNER | 1500.00 | | ADAMS | 1100.00 | | JAMES | 950.00 | | MILLER | 1300.00 | +--------+---------+ 10 rows in set (0.00 sec) like 为模糊查询，支持%或下划线匹配 %匹配任意个字符 下划线，一个下划线只匹配一个字符 找出名字里含有O字符的员工 mysql> select ename from emp where ename like '%o%'; +-------+ | ename | +-------+ | JONES | | SCOTT | | FORD | +-------+ 3 rows in set (0.00 sec) 找出第二个字母是A的 mysql> select ename from emp where ename like '_A%'; +--------+ | ename | +--------+ | WARD | | MARTIN | | JAMES | +--------+ 3 rows in set (0.00 sec) 7.3 排序 默认排序方式是升序 mysql> select ename,sal from emp order by sal; +--------+---------+ | ename | sal | +--------+---------+ | SMITH | 800.00 | | JAMES | 950.00 | | ADAMS | 1100.00 | | WARD | 1250.00 | | MARTIN | 1250.00 | | MILLER | 1300.00 | | TURNER | 1500.00 | | ALLEN | 1600.00 | | CLARK | 2450.00 | | BLAKE | 2850.00 | | JONES | 2975.00 | | SCOTT | 3000.00 | | FORD | 3000.00 | | KING | 5000.00 | +--------+---------+ 14 rows in set (0.00 sec) 指定为降序 mysql> select ename,sal from emp order by sal desc; +--------+---------+ | ename | sal | +--------+---------+ | KING | 5000.00 | | SCOTT | 3000.00 | | FORD | 3000.00 | | JONES | 2975.00 | | BLAKE | 2850.00 | | CLARK | 2450.00 | | ALLEN | 1600.00 | | TURNER | 1500.00 | | MILLER | 1300.00 | | WARD | 1250.00 | | MARTIN | 1250.00 | | ADAMS | 1100.00 | | JAMES | 950.00 | | SMITH | 800.00 | +--------+---------+ 14 rows in set (0.00 sec) 指定为升序 mysql> select ename,sal from emp order by sal asc; +--------+---------+ | ename | sal | +--------+---------+ | SMITH | 800.00 | | JAMES | 950.00 | | ADAMS | 1100.00 | | WARD | 1250.00 | | MARTIN | 1250.00 | | MILLER | 1300.00 | | TURNER | 1500.00 | | ALLEN | 1600.00 | | CLARK | 2450.00 | | BLAKE | 2850.00 | | JONES | 2975.00 | | SCOTT | 3000.00 | | FORD | 3000.00 | | KING | 5000.00 | +--------+---------+ 14 rows in set (0.00 sec) 多字段排序 查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。 mysql> select ename,sal from emp order by sal asc,ename asc; +--------+---------+ | ename | sal | +--------+---------+ | SMITH | 800.00 | | JAMES | 950.00 | | ADAMS | 1100.00 | | MARTIN | 1250.00 | | WARD | 1250.00 | | MILLER | 1300.00 | | TURNER | 1500.00 | | ALLEN | 1600.00 | | CLARK | 2450.00 | | BLAKE | 2850.00 | | JONES | 2975.00 | | FORD | 3000.00 | | SCOTT | 3000.00 | | KING | 5000.00 | +--------+---------+ 14 rows in set (0.00 sec) 综合一点的案例 mysql> select ename,sal from emp where sal between 1250 and 3000 order by sal desc; +--------+---------+ | ename | sal | +--------+---------+ | SCOTT | 3000.00 | | FORD | 3000.00 | | JONES | 2975.00 | | BLAKE | 2850.00 | | CLARK | 2450.00 | | ALLEN | 1600.00 | | TURNER | 1500.00 | | MILLER | 1300.00 | | WARD | 1250.00 | | MARTIN | 1250.00 | +--------+---------+ 10 rows in set (0.00 sec) 注意：关键字的顺序移动不能改变 select … from … where … order by …（排序总是在最后执行） 7.4 分组查询 在实际的应用中，可能有这样的需求，需要先进行分组，然后对每一组的数据进行操作，这个时候我们需要使用分组查询，将他们之间的关键字全部组合在一起： select … from … where … group by … order by… 执行顺序：from、where、group by、select、order by 注意：分组函数不能直接在where后使用 注意：分组函数不能直接使用在where后面 mysql> select ename,sal from emp where sal > min(sal); ERROR 1111 (HY000): Invalid use of group function select ename,sal from emp where sal > min(sal); 错误写法，因为分组函数在使用的时候必须先分组之后才能使用。where执行的时候，还没有分组。所以where后面不能出现分组函数。 mysql> select sum(sal) from emp; +----------+ | sum(sal) | +----------+ | 29025.00 | +----------+ 1 row in set (0.00 sec) select sum(sal) from emp; 可以使用，因为select在 group by 之后执行，group by 默认整张表是一组。（要充分理解SQL的执行顺序） group 关键字 找出每个工作岗位的工资和 思路：按照工作岗位分组，然后对工资求和。 mysql> select job,sum(sal) from emp group by job; +-----------+----------+ | job | sum(sal) | +-----------+----------+ | CLERK | 4150.00 | | SALESMAN | 5600.00 | | MANAGER | 8275.00 | | ANALYST | 6000.00 | | PRESIDENT | 5000.00 | +-----------+----------+ 5 rows in set (0.00 sec) 分析一下以上语句的执行顺序：先从emp表中查询数据，根据job字段进行分组，然后对每一组的数据进行sum（sal） 注意：以下情况的sql语句是错误的 select ename,job,sum(sal) from emp group by job;，不要这样写，没有意义。在mysql中可以执行，其他数据库就报错了。因为ename有14条记录，而job只有5条。 重要结论：在一条select语句中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其他的一律不能跟！！！ 练习：找出每个部门的最高薪资 实现思路：按照部门编号分组，求每一组的最大值。 mysql> select deptno,max(sal) from emp group by deptno; +--------+----------+ | deptno | max(sal) | +--------+----------+ | 20 | 3000.00 | | 30 | 2850.00 | | 10 | 5000.00 | +--------+----------+ 3 rows in set (0.00 sec) 两个字段联合分组 Q:找出“每个部门，不同工作岗位”的最高薪资： mysql> select deptno,job,max(sal) from emp group by deptno,job; +--------+-----------+----------+ | deptno | job | max(sal) | +--------+-----------+----------+ | 20 | CLERK | 1100.00 | | 30 | SALESMAN | 1600.00 | | 20 | MANAGER | 2975.00 | | 30 | MANAGER | 2850.00 | | 10 | MANAGER | 2450.00 | | 20 | ANALYST | 3000.00 | | 10 | PRESIDENT | 5000.00 | | 30 | CLERK | 950.00 | | 10 | CLERK | 1300.00 | +--------+-----------+----------+ 9 rows in set (0.00 sec) 找出每个部门最高薪资，要求显示最高薪资大于3000的 方法一：找出每个部门最高薪资，然后显示最高薪资大于3000的 mysql> select deptno,max(sal) from emp group by deptno having max(sal)>3000; +--------+----------+ | deptno | max(sal) | +--------+----------+ | 10 | 5000.00 | +--------+----------+ 1 row in set (0.00 sec) 注意：使用having可以对分完组之后的数据进一步过滤，注意having不能单独使用，having不能代替where，having必须和group by联合使用。 方法二：先将大于3000的都找出来，然后进行分组。 mysql> select deptno,max(sal) from emp where sal>3000 group by deptno; +--------+----------+ | deptno | max(sal) | +--------+----------+ | 10 | 5000.00 | +--------+----------+ 1 row in set (0.00 sec) 优化策略where和having，优先选择where，where实在完成不了了，再选择having。 找出每个部门的平均薪资，要求显示平均薪资高于2500的 mysql> select deptno,avg(sal) from emp group by deptno having avg(sal)>2500; +--------+-------------+ | deptno | avg(sal) | +--------+-------------+ | 10 | 2916.666667 | +--------+-------------+ 1 row in set (0.00 sec) 7.5 总结 select ... from ... where ... group by ... having ... order by ... 以上关键字只能按照这个顺序来，不能颠倒。 执行顺序：1. from 2. where 3. group by 4. having 5. select 6. order by 8.函数 8.1 单行处理函数 特点：一个输入对应一个输出 8.1.1字符串函数(JAVA String函数类似) upper、lower函数改变大小写 select lower(ename) from emp; 变成小写 mysql> select lower(ename) from emp; +--------------+ | lower(ename) | +--------------+ | smith | | allen | | ward | | jones | | martin | | blake | | clark | | scott | | king | | turner | | adams | | james | | ford | | miller | +--------------+ 14 rows in set (0.00 sec) substr,substring函数截取，索引从1开始（没有0） mysql> select substr(ename,1,1) from emp; +-------------------+ | substr(ename,1,1) | +-------------------+ | S | | A | | W | | J | | M | | B | | C | | S | | K | | T | | A | | J | | F | | M | +-------------------+ 14 rows in set (0.00 sec) 练习：找到第一个字母以A开头的员工信息： # 方法1：模糊查询1 mysql> select ename from emp where ename like 'A%'; +-------+ | ename | +-------+ | ALLEN | | ADAMS | +-------+ 2 rows in set (0.00 sec) # 方法2：substr函数 mysql> select ename from emp where substr(ename,1,1) = 'A'; +-------+ | ename | +-------+ | ALLEN | | ADAMS | +-------+ 2 rows in set (0.00 sec) concat函数：拼接字符串 length函数用于获取参数值的字节个数 # 获取对应字段的长度 mysql> select length(ename) enamelength from emp; +-------------+ | enamelength | +-------------+ | 5 | | 5 | | 4 | | 5 | | 6 | | 5 | | 5 | | 5 | | 4 | | 6 | | 5 | | 5 | | 4 | | 6 | +-------------+ 14 rows in set (0.00 sec) # 首字母大写，其他字母小写 mysql> select concat(upper(substr(ename,1,1)),lower(substr(ename,2,length(ename) - 1 ))) as result from emp; +--------+ | result | +--------+ | Smith | | Allen | | Ward | | Jones | | Martin | | Blake | | Clark | | Scott | | King | | Turner | | Adams | | James | | Ford | | Miller | +--------+ 14 rows in set (0.00 sec) instr函数返回字符串第一次出现的索引，若找不到，则返回0 trim函数去前后空格 mysql> select * from emp where ename = trim(' KING'); +-------+-------+-----------+------+------------+---------+------+--------+ | EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO | +-------+-------+-----------+------+------------+---------+------+--------+ | 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 | +-------+-------+-----------+------+------------+---------+------+--------+ 1 row in set (0.00 sec) lpad函数用指定字符实现左填充指定长度 rpad函数同上 replace函数替换 8.1.2 数学函数 round()函数四舍五入（前一个参数为输入值，后一个参数为保留小数点位数，负数代表正数位数） 如： select round(1236.567, -1) as result from emp; 1240，保留到十位 select round(1236.567, -2) as result from emp; 1200，保留到百位 rand()生成随机数 #生成100以内的随机数 mysql> select round(rand()*100,0) from emp; +---------------------+ | round(rand()*100,0) | +---------------------+ | 31 | | 16 | | 88 | | 93 | | 100 | | 20 | | 2 | | 51 | | 46 | | 77 | | 47 | | 3 | | 77 | | 75 | +---------------------+ 14 rows in set (0.00 sec) ifnull标记null的使用取代值 # 求解年度工资 mysql> select ename,(sal+comm)*12 as yearsal from emp; +--------+----------+ | ename | yearsal | +--------+----------+ | SMITH | NULL | | ALLEN | 22800.00 | | WARD | 21000.00 | | JONES | NULL | | MARTIN | 31800.00 | | BLAKE | NULL | | CLARK | NULL | | SCOTT | NULL | | KING | NULL | | TURNER | 18000.00 | | ADAMS | NULL | | JAMES | NULL | | FORD | NULL | | MILLER | NULL | +--------+----------+ 14 rows in set (0.00 sec) # 防止null出现 mysql> select ename,(sal+ifnull(comm,0))*12 as yearsal from emp; +--------+----------+ | ename | yearsal | +--------+----------+ | SMITH | 9600.00 | | ALLEN | 22800.00 | | WARD | 21000.00 | | JONES | 35700.00 | | MARTIN | 31800.00 | | BLAKE | 34200.00 | | CLARK | 29400.00 | | SCOTT | 36000.00 | | KING | 60000.00 | | TURNER | 18000.00 | | ADAMS | 13200.00 | | JAMES | 11400.00 | | FORD | 36000.00 | | MILLER | 15600.00 | +--------+----------+ 14 rows in set (0.00 sec) 注意：Null只要参与了运算，结果为Null。为了避免这个想象，需要使用ifnull函数。用法：ifnull(数据，被当做哪个值) select ename, (sal+ifnull(comm,0)) * 12 as yearsal from emp; comm如果为null，当做0处理。 ceil函数向上取整 floor函数向下取整 truncate函数截断 mod函数取余 8.1.3 日期函数 now函数 获取当前时间，获取的时间带有：时分秒信息！是datetime类型的。 curdate函数返回当前日期，不包含时间 curtime函数返回当前时间，不包含日期 str_to_date函数 将字符串转化成日期类型 语法格式：str_to_date(‘字符串日期’, ‘日期格式’)。 str_to_date函数可以把字符串varchar转换成日期date类型数据，通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，需要通过该函数将字符串转换成date。 date_format函数 1.将日期类型转换成特定格式的字符串。 date_format(birth, '%Y/%d/%m') mysql默认格式：%Y-%d-%m。 将日期转化为字符串格式 timestampdiff(interval，datetime1，datetime2)函数 比较的单位interval可以为以下数值 FRAC_SECOND。表示间隔是毫秒 8.1.4 其他函数 case … when … then … when … then … else … end 例如：当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%，其他正常。（不是修改数据库，只是查询结果显示为工资上调） mysql> select -> ename, -> job, -> sal as oldsal, -> (case job when 'MANAGER' then sal*1.1 when 'SALESMAN' then sal*1.5 else sal end) as newsal -> from -> emp; +--------+-----------+---------+---------+ | ename | job | oldsal | newsal | +--------+-----------+---------+---------+ | SMITH | CLERK | 800.00 | 800.00 | | ALLEN | SALESMAN | 1600.00 | 2400.00 | | WARD | SALESMAN | 1250.00 | 1875.00 | | JONES | MANAGER | 2975.00 | 3272.50 | | MARTIN | SALESMAN | 1250.00 | 1875.00 | | BLAKE | MANAGER | 2850.00 | 3135.00 | | CLARK | MANAGER | 2450.00 | 2695.00 | | SCOTT | ANALYST | 3000.00 | 3000.00 | | KING | PRESIDENT | 5000.00 | 5000.00 | | TURNER | SALESMAN | 1500.00 | 2250.00 | | ADAMS | CLERK | 1100.00 | 1100.00 | | JAMES | CLERK | 950.00 | 950.00 | | FORD | ANALYST | 3000.00 | 3000.00 | | MILLER | CLERK | 1300.00 | 1300.00 | +--------+-----------+---------+---------+ 14 rows in set (0.00 sec) version() database() user() format() 8.2 分组函数 也叫多行处理函数，多个输入对应一个输出 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-05-11 16:11:40 "},"javaweb/MyBatis.html":{"url":"javaweb/MyBatis.html","title":"MyBatis","keywords":"","body":"MyBatis学习 环境配置： JDK1.8 MySql maven idea开发工具 回顾： JDBC MySql java基础 Maven知识 Junit SSM框架：配置文件，最好的学习方式是查阅官网文档点击这里 简介 什么是MyBatis? Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-12 15:58:13 "},"javaweb/Spring.html":{"url":"javaweb/Spring.html","title":"Spring","keywords":"","body":"Spring 1.简介 Spring：给软件行业带来春天 interface21：Spring 前身。也是早期版本 Rod Johnson：创始人 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-04-12 15:58:13 "},"javaweb/SpringBoot学习1.html":{"url":"javaweb/SpringBoot学习1.html","title":"SpringBoot1","keywords":"","body":"SpringBoot学习(kuangshen) 1.微服务阶段学习 javase：OOP mysql：数据持久化 html+css+js+jquery+框架：视图，框架不熟练，css不好用 javaweb：独立开发MVC三层架构的网站（原始框架） ssm：（Spring+SpringMVC+MyBatis）框架：简化了我们的开发流程，配置开始也比较复杂 war：tomcat的运行 spring简化：SpringBoot -jar 内嵌tomcat，微服务架构 服务会越来越多：如springcloud 1.1 学习路径 springboot 什么是springboot 配置如何编写 yaml 自动装配原理（非常重要） 集成web开发 集成数据库 分布式开发：DUbbo+zookeeper swagger接口文档 任务调度 SpringSerurty:Shiro linux学习 springcloud 微服务 springcloud入门 Restful Eureka Ngnix Ribbon Feign Hystrix Zuul:路由网关 SpringCloud config：git JVM机制 2.什么是SpringBoot Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 重点思想：Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置 3.什么是微服务 MVC 三层架构 MVVM 微服务架构 DUbbo：https://dubbo.apache.org/zh/docs/ 原文文章地址：https://martinfowler.com/articles/microservices.html （作者：Martin Fowler） 翻译版本：https://www.cnblogs.com/liuning8023/p/4493156.html 4.新手上路 环境： jdk 1.8 maven springboot idea 官方：提供一个快速生产的网站，但是IDEA本身自带 4.1 网站初始化 网址：https://start.spring.io/ 4.2 IDEA创建 选择依赖环境 如果想更改banner，可以在resource创建一个banner.txt文件https://www.bootschool.net/ascii 如佛祖效果如下： //////////////////////////////////////////////////////////////////// // _ooOoo_ // // o8888888o // // 88\" . \"88 // // (| ^_^ |) // // O\\ = /O // // ____/`---'\\____ // // .' \\\\| |// `. // // / \\\\||| : |||// \\ // // / _||||| -:- |||||- \\ // // | | \\\\\\ - /// | | // // | \\_| ''\\---/'' | | // // \\ .-\\__ `-` ___/-. / // // ___`. .' /--.--\\ `. . ___ // // .\"\" '_/___.' >'\"\". // // | | : `- \\`.;`\\ _ /`;.`/ - ` : | | // // \\ \\ `-. \\_ __\\ /__ _/ .-` / / // // ========`-.____`-.___\\_____/___.-`____.-'======== // // `=---=' // // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // // 佛祖保佑 永不宕机 永无BUG // //////////////////////////////////////////////////////////////////// 5.自动装配原理初探 5.1 porm.xml文件 spring-boot-dependences：核心依赖在父工程中 springboot引入时无需引入版本，原因在于父工程已经引入版本 org.springframework.boot spring-boot-starter-parent 2.6.4 其中具备一个父级依赖 org.springframework.boot spring-boot-dependencies 2.6.4 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 可以理解为springboot的一个场景 spring-boot-starters 可以引入所有的依赖 springboot的作用在于把场景变成启动器 org.springframework.boot spring-boot-starters springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； org.springframework.boot spring-boot-starter-web 5.2主启动文件 5.2.1 默认主启动文件 /程序主入口 //@SpringBootApplication 用来标注 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { //以为是启动了一个方法，其实是启动了一个服务 SpringApplication.run(DemoApplication.class, args); } } 5.2.2 @SpringBootApplication 作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { ... } @ComponentScan: 这个注解在Spring中很重要 ,它对应XML配置中的元素 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 @SpringBootConfiguration 作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； @EnableAutoConfiguration @EnableAutoConfiguration ：开启自动配置功能 @EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效； @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { ... } @import ：Spring底层注解@import ， 给容器中导入一个组件 @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ； AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码： protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations; } 这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法 public static List loadFactoryNames(Class factoryType, @Nullable ClassLoader classLoader) { ClassLoader classLoaderToUse = classLoader; if (classLoader == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } String factoryTypeName = factoryType.getName(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList()); } 我们继续点击查看 loadSpringFactories 方法 private static Map> loadSpringFactories(ClassLoader classLoader) { Map> result = (Map)cache.get(classLoader); if (result != null) { return result; } else { HashMap result = new HashMap(); try { Enumeration urls = classLoader.getResources(\"META-INF/spring.factories\"); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Entry entry = (Entry)var6.next(); String factoryTypeName = ((String)entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); String[] var10 = factoryImplementationNames; int var11 = factoryImplementationNames.length; for(int var12 = 0; var12 { return new ArrayList(); })).add(factoryImplementationName.trim()); } } } result.replaceAll((factoryType, implementations) -> { return (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); }); cache.put(classLoader, result); return result; } catch (IOException var14) { throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var14); } } } 其中META-INF/spring.factories这个文件多次出现 找到这个文件 WebMvcAutoConfiguration结构 所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 5.2.3 SpringApplication 我最初以为就是运行了一个main方法，没想到却开启了一个服务； @SpringBootApplication public class SpringbootApplication { public static void main(String[] args) { SpringApplication.run(SpringbootApplication.class, args); } } SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； 这个类主要做了以下四件事情： 断定应用是普通应用还是web应用 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 查看构造器： public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass(); } run方法核心流程 核心代码部分 public ConfigurableApplicationContext run(String... args) { long startTime = System.nanoTime(); DefaultBootstrapContext bootstrapContext = this.createBootstrapContext(); ConfigurableApplicationContext context = null; this.configureHeadlessProperty(); SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting(bootstrapContext, this.mainApplicationClass); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments); this.configureIgnoreBeanInfo(environment); Banner printedBanner = this.printBanner(environment); context = this.createApplicationContext(); context.setApplicationStartup(this.applicationStartup); this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); this.refreshContext(context); this.afterRefresh(context, applicationArguments); Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime); if (this.logStartupInfo) { (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup); } listeners.started(context, timeTakenToStartup); this.callRunners(context, applicationArguments); } catch (Throwable var12) { this.handleRunFailure(context, var12, listeners); throw new IllegalStateException(var12); } try { Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime); listeners.ready(context, timeTakenToReady); return context; } catch (Throwable var11) { this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null); throw new IllegalStateException(var11); } } 6.yaml配置注入 SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yaml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； 例如：server.port=8081 6.1 yaml概述 YAML是 \"YAML Ain't a Markup Language\" （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言） 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 8081 yaml配置： server: port: 8081(注意中间一定要有空格a) 6.2 基本语法 说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: \"kuang \\n shen\" 输出 ：kuang 换行 shen '' 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 6.2.1 对象、Map（键值对) #对象、Map格式 k: v1: 如 student: name: qinjiang age: 3 其行内写法 student: {name: qinjiang,age: 3} 6.2.2 数组 pets: - cat - dog - snake - pig pets1: [dog,cat,pig,snake] 6.2.3 修改SpringBoot的默认端口号 server: port: 8081 6.3注入配置文件 6.3.1 原有的方法 @Component //注册bean到容器中 public class Dog { private String name; private Integer age; //有参无参构造、get、set方法、toString()方法 } 加入注解@Vaulue后： @Component //注册bean public class Dog { @Value(\"阿黄\") private String name; @Value(\"18\") private Integer age; ... } 在SpringBoot的测试类下注入狗狗输出一下； @SpringBootTest class DemoApplicationTests { @Autowired //将狗狗自动注入进来 Dog dog; @Test public void contextLoads() { System.out.println(dog); //打印看下狗狗对象 } } 运行测试： Dog{name='阿黄', age=18} 6.3.2 yaml注入配置 Person类文件 @Component //注册bean到容器中 @ConfigurationProperties(prefix = \"person\") public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map maps; private List lists; private Dog dog; ... } yaml配置文件 person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - girl - music dog: name: 旺财 age: 1 在测试文件添加配置 @SpringBootTest class DemoApplicationTests { @Autowired Person person; //将person自动注入进来 @Test public void contextLoads() { System.out.println(person); //打印person信息 } } 运行结果 Person{name='qinjiang', age=3, happy=false, birth=Sat Jan 01 00:00:00 CST 2000, maps={k1=v1, k2=v2}, lists=[code, girl, music], dog=Dog{name='旺财', age=1}} 6.3.3 如何指定配置文件 @PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 实例 @PropertySource(value = \"classpath:person.properties\") @Component //注册bean public class Person { @Value(\"${name}\") private String name; ...... } 运行结果： Person{name='jiaoery', age=null, happy=null, birth=null, maps=null, lists=null, dog=null} 6.3.4 使用占位符 甚至部分元素可用占位符生成随机数 person: name: qinjiang${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - girl - music dog: name: ${person.hello:other}_旺财 age: 1 运行结果 Person{name='qinjiang2d991a32-8626-4455-b277-38a1ffce25d2', age=1576338666, happy=false, birth=Sat Jan 01 00:00:00 CST 2000, maps={k1=v1, k2=v2}, lists=[code, girl, music], dog=Dog{name='other_旺财', age=1}} 6.3.5回顾properties配置 【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings-->FileEncodings 中配置； 除了yaml文件，其实properties文件也可实现对应的效果 实例 1.新建编辑配置文件 user.properties 2.配置文件 user1.name=kuangshen user1.age=18 user1.sex=男 3.我们在User类上使用@Value来进行注入 @Component //注册bean @PropertySource(value = \"classpath:user.properties\") public class User { //直接使用@value @Value(\"${user.name}\") //从配置文件中取值 private String name; @Value(\"#{9*2}\") // #{SPEL} Spring表达式 private int age; @Value(\"男\") // 字面量 private String sex; } 4.Springboot测试 @SpringBootTest class DemoApplicationTests { @Autowired User user; @Test public void contextLoads() { System.out.println(user); } } 运行结果 User{name='jixiang', age=18, sex='男'} 6.3.6 对比@Value 和@ConfigurationProperties 1.@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 2.松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下 3.JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 4.复杂类型封装，yml中可以封装对象 ， 使用value就不支持 总结 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ 7.JSR303数据校验及多环境切换 7.1 如何使用 @Component //注册bean @ConfigurationProperties(prefix = \"person\") @Validated //数据校验 public class Person { @Email(message=\"邮箱格式错误\") //name必须是邮箱格式 private String name; } 使用数据校验，可以保证数据的正确性； Ps:前后端都需要做校验 7.2 常见参数 @NotNull(message=\"名字不能为空\") private String userName; @Max(value=120,message=\"年龄最大不能查过120\") private int age; @Email(message=\"邮箱格式错误\") private String email; 空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included. 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则 .......等等 除此以外，我们还可以自定义一些数据校验规则 7.3 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 7.3.1 多配置文件(properties) 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： #比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试； #我们启动SpringBoot，就可以看到已经切换到dev下的配置了； spring.profiles.active=dev 7.3.2 多配置文件(yaml) 和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! server: port: 8081 #选择要激活那个环境块 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev #配置环境的名称 --- server: port: 8084 spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 7.3.3 配置文件加载位置 原文链接 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 优先级1：项目路径下的config文件夹配置文件 优先级2：项目路径下配置文件 优先级3：资源路径下的config文件夹配置文件 优先级4：资源路径下配置文件 SpringBoot会从这四个位置全部加载主配置文件；互补配置； Ps:具体可以参考demo 7.3.4 拓展，运维小技巧 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 java -jar spring-boot-config.jar --spring.config.location=F:/application.properties 8.自动装配原理再理解 8.1 分析自动配置原理 以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件； @Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中 @EnableConfigurationProperties({HttpProperties.class}) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnWebApplication( type = Type.SERVLET ) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnClass({CharacterEncodingFilter.class}) //判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； @ConditionalOnProperty( prefix = \"spring.http.encoding\", value = {\"enabled\"}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; } //。。。。。。。 } 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 @ConditionalOnProperty( prefix = \"server.servlet.encoding\", value = {\"enabled\"}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { ... } 这就是自动装配的原理！ 8.2 精髓 1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 8.3 了解：@Conditional 自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； #开启springboot的调试类 debug=true Positive matches:（自动配置类启用的：正匹配） Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 9.SpringBoot Web开发 jar：webapp 自动装配 springboot配置了什么？ xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 需要解决的问题： 导入静态资源 首页 jsp，模版引擎Thymeleaf 装配拓展SpringMvc 增删改查 拦截器 国际化 9.1 静态资源 新建项目resource下的结构 static存储静态变量，比如说，图片，文件，html（不使用thymeleaf这类动态配置库） templates存储模版，也就是动态配置库，一般这里结合thymeleaf框架使用 9.1.1 默认静态资源路径 classpath:/static, classpath:/public, classpath:/resources, classpath:/META-INF/resources classpath 在项目中就相当于src/main/resources文件夹. 9.1.2 自定义静态资源路径 spring: web: resources: static-locations: classpath:templates/ 我们配置了静态资源路径映射之后，我们只能访问这个路径下面的资源，也就是相当于自定义了静态资源路径，就是说默认的静态资源路径都会失效。 9.2 首页和图标定制 图标修改需要先关闭默认图标 关闭默认图标 spring.mvc.favicon.enabled=false 较新版本中，不需要关闭默认图标，只需要把图标名称和格式写为：favicon.ico，放到静态资源目录下就可以了 10.thymeleaf模版引擎 Q：什么是模版引擎？ Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf 定义：Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。它与 JSP，Velocity，FreeMaker 等模板引擎类似，也可以轻易地与 Spring MVC 等 Web 框架集成。与其它模板引擎相比，Thymeleaf 最大的特点是，即使不启动 Web 应用，也可以直接在浏览器中打开并正确显示模板页面 。 10.1 引入Thymeleaf maven引入依赖包 org.springframework.boot spring-boot-starter-thymeleaf maven下载的包 注意：（版本有不同） 10.2 如何使用Thymeleaf 项目结构 首先是controller package com.Thymeleaf.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; @Controller public class urlController { @GetMapping(\"index\")//页面的url地址 public String getindex(Model model)//对应函数 { model.addAttribute(\"name\",\"jiaoery\"); return \"index\";//与templates中index.html对应 } } 上述代码就是一个完整的controller。部分含义如下： @controller 注解的意思就是声明这个java文件为一个controller控制器。 @GetMapping(\"index\") 其中@GetMapping的意思是请求的方式为get方式(即可通过浏览器直接请求)，而里面的index表示这个页面(接口)的url地址(路径)。即在浏览器对项目网页访问的地址。 getindex() 是@GetMapping(\"index\")注解对应的函数，其类型为String类型返回一个字符串，参数Model类型即用来储存数据供我们Thymeleaf页面使用。 model.addAttribute(\"name\",\"bigsai\") 就是Model存入数据的书写方式，Model是一个特殊的类，相当于维护一个Map一样，而Model中的数据通过controller层的关联绑定在view层(即Thymeleaf中)可以直接使用。 return \"index\"：这个index就是在templates目录下对应模板(本次为Thymeleaf模板)的名称，即应该对应hello.html这个Thymeleaf文件(与页面关联默认规则为：templates目录下返回字符串.html)。 其次是index.html中的网页数据 title hello 第一个Thymeleaf程序 name是jiaery(我是离线数据) 运行结果： 不使用thymeleaf 使用thymeleaf 基本到这里算入门了 10.3 Thymeleaf规则 Thymeleaf 模板引擎具有以下特点： 动静结合：Thymeleaf 既可以直接使用浏览器打开，查看页面的静态效果，也可以通过 Web 应用程序进行访问，查看动态页面效果。 开箱即用：Thymeleaf 提供了 Spring 标准方言以及一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。 与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 T 10.4 Thymeleaf 语法 Springboot官方提供的配置内容有以下： # THYMELEAF (ThymeleafAutoConfiguration) spring.thymeleaf.cache=true # Whether to enable template caching. spring.thymeleaf.check-template=true # Whether to check that the template exists before rendering it. spring.thymeleaf.check-template-location=true # Whether to check that the templates location exists. spring.thymeleaf.enabled=true # Whether to enable Thymeleaf view resolution for Web frameworks. spring.thymeleaf.enable-spring-el-compiler=false # Enable the SpringEL compiler in SpringEL expressions. spring.thymeleaf.encoding=UTF-8 # Template files encoding. spring.thymeleaf.excluded-view-names= # Comma-separated list of view names (patterns allowed) that should be excluded from resolution. spring.thymeleaf.mode=HTML # Template mode to be applied to templates. See also Thymeleaf's TemplateMode enum. spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL. spring.thymeleaf.reactive.chunked-mode-view-names= # Comma-separated list of view names (patterns allowed) that should be the only ones executed in CHUNKED mode when a max chunk size is set. spring.thymeleaf.reactive.full-mode-view-names= # Comma-separated list of view names (patterns allowed) that should be executed in FULL mode even if a max chunk size is set. spring.thymeleaf.reactive.max-chunk-size=0 # Maximum size of data buffers used for writing to the response, in bytes. spring.thymeleaf.reactive.media-types= # Media types supported by the view technology. spring.thymeleaf.servlet.content-type=text/html # Content-Type value written to HTTP responses. spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL. spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names (patterns allowed) that can be resolved. 上面的配置有些我们可能不常使用，因为Springboot官方做了默认配置大部分能够满足我们的使用需求，但如果你的项目有特殊需求也需要妥善使用这些配置 几个特别配置 比如spring.thymeleaf.cache=false是否允许页面缓存的配置，我们在开发时候要确保页面是最新的所以需要禁用缓存；而在上线运营时可能页面不常改动为了减少服务端压力以及提升客户端响应速度会允许页面缓存的使用。 再比如在开发虽然我们大部分使用UTF-8多一些，我们可以使用spring.thymeleaf.encoding=UTF-8来确定页面的编码，但如果你的项目是GBK编码就需要将它改成GBK。 另外Springboot默认模板引擎文件是放在templates目录下：spring.thymeleaf.prefix=classpath:/templates/,如果你有需求将模板引擎也可修改配置，将templates改为自己需要的目录。同理其他的配置如果需要自定义化也可参照上面配置进行修改。 10.4.1 标签 常用的标签 标签 作用 示例 th:id 替换id th:text 文本替换 bigsai th:utext 支持html的文本替换 content th:object 替换对象 th:value 替换值 th:each 迭代 th:href 替换超链接 超链接 th:src 替换资源 10.4.2 链式表达@{…} 上面我们已经学习到Thymeleaf是一个基于html的模板引擎，但是我们还是需要加入特定标签来声明和使用Thymeleaf的语法。我们需要在Thymeleaf的头部加Thymeleaf标识： 在Thymeleaf 中，如果想引入链接比如link，href，src，需要使用@{资源地址}引入资源。其中资源地址可以static目录下的静态资源，也可以是互联网中的绝对资源。 引入css 引入JavaScript： 超链接： 超链接 最终效果 10.4.3 变量表达式: ${...} 在Thymeleaf中可以通过${…}进行取值，这点和ONGL表达式语法一致。 首先引入一个bean类Child public class Child { private String name; private int age; private String detail; public Child(String name, int age, String detail) { this.name = name; this.age = age; this.detail = detail; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getDetail() { return detail; } public void setDetail(String detail) { this.detail = detail; } } 然后在Model中添加一些数据 @GetMapping(\"index\") public String getIndex(Model model){ Child user1=new Child(\"bigsai\",22,\"一个幽默且热爱java的社会青年\"); List userList=new ArrayList<>(); userList.add(\"zhang san 66\"); userList.add(\"li si 66\"); userList.add(\"wang wu 66\"); Map map=new HashMap<>(); map.put(\"place\",\"cloudwalk\"); map.put(\"feeling\",\"very well\"); //数据添加到model中 model.addAttribute(\"name\",\"jiaoery\");//普通字符串 model.addAttribute(\"user\",user1);//储存javabean model.addAttribute(\"userlist\",userList);//储存List model.addAttribute(\"map\",map);//储存Map model.addAttribute(\"name\",\"jiaoery\"); return \"index\";//与templates中index.html对应 } 然后在index.html文件下使用数据 title hello 第一个Thymeleaf程序 name是jiaoery(我是离线数据) 超链接 普通字符串 JavaBean对象 介绍 年龄 介绍 List取值 Map取值 place: feeling: Map遍历 运行结果 10.4.4 选择变量表达式: *{...} 变量表达式不仅可以写成${...}，而且还可以写成*{...}。（可以理解为两者相等） 10.4.5 消息表达: #{...} 这里是使用配置参数的方式实现，如yaml或propriety文件配置；通俗易懂的来说#{…}语法就是用来读取配置文件中数据的。在Thymeleaf你可以使用#{...}语法获取消息， 首先在templates目录下建立home.properties中写入以下内容： jiaoery.name=jiaoery jiaoery.age=22 province=chongqing 在application.properties中加入以下内容： spring.messages.basename=templates/home 或者使用yaml文件下添加(注意是三行，也注意空格) messages: basename: templates/home 然后H5中添加对应的配置文件 消息表达 name 年龄 province 最终结果 11.装配SpringMVC Spring Boot通过WebMvcAutoConfiguration来提供一些默认配置；大多数时候使用默认的配置即可满足要求。但有时可能需要做一些个性化定制，此时就需要使用以下方式来进行。 11.1 使用EnableWebMvc注解 //只是泗洪Configuration的情况下，可以对某些mvc配置做个性化设置 @Configuration //注解不能轻易使用，一旦使用这个注解，就必须把所有mvc的配置都实现 @EnableWebMvc public class MyMvcConfig implements WebMvcConfigurer { /** * 配置RequestMapping注解中指定的路径模式与实际访问路径之间映射的处理规则 * @param configurer */ @Override public void configurePathMatch(PathMatchConfigurer configurer) { /** * 设置路径后是否包含/ * 假设RequestMapping注解中指定的路径是/test * 设置成True时，会同时处理/test/和/test的请求 * 设置成False时，只会处理/test的请求 * 默认是True */ configurer.setUseTrailingSlashMatch(false); /** * 配置后置模式匹配是否仅在配置内容协商中明确指定的路径扩展名称时生效 * 举个例子：假设WebMvcConfigurer中覆盖了configureContentNegotiation方法进行以下处理： * @Override * public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { * configurer.mediaType(\"pdf\", MediaType.APPLICATION_PDF); *} * 当setUseRegisteredSuffixPatternMatch配置成TRUE时，即使setUseSuffixPatternMatch设置成True， * 在访问/test.do时也不会命中被RequestMapping注解值为/test的Controller； * 只有在访问/test.pdf时才能正常访问，其它任何的/test.txt或者/test.doc等均会报404； * 默认情况下该值是False */ configurer.setUseRegisteredSuffixPatternMatch(true); } /** * 配置路径后缀与访问的内容类型的映射关系 * @param configurer */ @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { /** * 设置后缀与访问的内容类型的映射关系； * 如以下示例，默认情况下.txt表明是TXT类型，现在将其指定为PDF类型； * 那么在访问http://localhost/test.txt时将会将其当成PDF文件类型使用PDF阅读工具打开。 */ configurer.mediaType(\"txt\", MediaType.APPLICATION_PDF); /** * 是否忽略请求报文头中的内容类型 * 默认情况下是False，即以请求报文头中的类型为准 */ configurer.ignoreAcceptHeader(true); /** * 是否通过传入的参数（默认名称是format）来决定内容类型 * 需要结合mediaType方法一起使用； * 如通过mediaType指定txt为PDF类型；则访问路径http://localhost/test?format=txt时会当成PDF类型处理 * 默认为False */ configurer.favorParameter(true); /** * 是否优先使用后缀为决定内容类型 * 为False时优先使用Header中的类型 * 为True时优先使用.后面指定的类型 * 默认为True */ configurer.favorPathExtension(false); /** * 是否仅处理明确通过mediaType注册的类型请求 */ configurer.useRegisteredExtensionsOnly(true); } /** * 配置当通过DispatcherServlet没有查找到对应的Handler处理时，是否使用默认的DefaultServletHttpRequestHandler来进行处理 * @param configurer */ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } /** * 增加对象转换方法和格式化方法 * * @param registry */ @Override public void addFormatters(FormatterRegistry registry) { /** * 处理前台传入类型为String且Controller中接入参数也是String的参数转换 * 将前台传入参数值附加[converted]后在调用Controller时使用； * 如前台通过访问http://localhost/test?a=b调用Controller，在Controller获取到a的值时将会是a[converted] */ registry.addConverter(new Converter() { @Nullable @Override public String convert(String source) { return null == source? null : source + \"[converted]\"; } }); /** * 处理当前台传入是String类型而后台Controller接收的参数是Integer类型时的转换规则 */ registry.addConverter(new Converter() { @Nullable @Override public Integer convert(String source) { return null == source? null : Integer.valueOf(source) + 100; } }); } /** * 配置静态资源访问的路径规则以及查找静态资源的路径 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { /** * 处理所有HTML的请求，到static目录下查找对应的资源 */ registry.addResourceHandler(\"/**.html\") //处理的路径规则 .addResourceLocations(\"classpath:/static/\") //到哪些目录下去查找静态资源 ; } /** * 进行跨域访问相关配置 * @param registry */ @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/test1/**\") //可以跨域访问的URL路规则 .allowedOrigins(\"http://localhost:8080/\") //可以跨域访问的访问者 .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\") //可以跨域访问的方法 .allowedHeaders(\"\") //可以跨域访问的Headers ; } @Override public void addViewControllers(ViewControllerRegistry registry) { /** * 配置路径跳转；将某个路径的请求映射到另外一个路径 * 如将所有http://localhost/b/**的请求全部跳转到http://localhost/test上去 */ registry.addRedirectViewController(\"/b/**\", \"/test\"); /** * 将路径映射到某个名称为指定值的视图上 * 访问/c会返回a.html的视图 * 一般与ViewResolver结合使用 */ registry.addViewController(\"/c\").setViewName(\"a\"); /** * 指定某个请求的状态码，而不返回任何的内容 * 如下面将/badRequest请求返回状态码为400，而没有返回其它内容 */ registry.addStatusController(\"/badRequest\", HttpStatus.BAD_REQUEST); } @Override public void configureViewResolvers(ViewResolverRegistry registry) { /** * 添加HTML的视图解析器 * 本示例完成以下功能：将Controller返回的String类型的视图名称添加前缀及后缀； * 如返回的是a，那么处理后对应的视图将会是/a.html */ registry.viewResolver(new InternalResourceViewResolver(\"/\", \".html\")); } } 12.页面国际化 12.1 配置准备工作 首先，需要配置文件编译格式全部为：UTF_8 然后创建资源文件 若是没有这个窗口，可以去下载一个插件plugin ：Resource Bundle Editor 最后编辑增加相应的配置 到这里已经完成全部配置 12.2 使用配置 其中，源码中的核心代码如下： // 获取 properties 传递过来的值进行判断 @Bean public MessageSource messageSource(MessageSourceProperties properties) { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) { // 设置国际化文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); } if (properties.getEncoding() != null) { messageSource.setDefaultEncoding(properties.getEncoding().name()); } messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) { messageSource.setCacheMillis(cacheDuration.toMillis()); } messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; } 首先需要在配置文件 application.yaml下添加配置 properties文件 spring.messages.basename=i18n.login yaml文件（注意空格） spring: ​ messages: ​ basename: i18n.login 网页部分修改效果如下： 运行就是中文界面了 然后实现中英文切换 在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！ 我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置： @Override @Bean @ConditionalOnMissingBean(name = DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME) public LocaleResolver localeResolver() { // 容器中没有就自己配，有的话就用用户配置的 if (this.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.webProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.webProperties.getLocale()); return localeResolver; } 这里再看一下AcceptHeaderLocaleResolver这个类的内部实现 public Locale resolveLocale(HttpServletRequest request) { Locale defaultLocale = this.getDefaultLocale(); // 默认的就是根据请求头带来的区域信息获取Locale进行国际化 if (defaultLocale != null && request.getHeader(\"Accept-Language\") == null) { return defaultLocale; } else { Locale requestLocale = request.getLocale(); List supportedLocales = this.getSupportedLocales(); if (!supportedLocales.isEmpty() && !supportedLocales.contains(requestLocale)) { Locale supportedLocale = this.findSupportedLocale(request, supportedLocales); if (supportedLocale != null) { return supportedLocale; } else { return defaultLocale != null ? defaultLocale : requestLocale; } } else { return requestLocale; } } } 也就是说，这里需要我们自己配置一个localeResolver //可以在链接上携带区域信息 public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的 //如果请求链接不为空 if (!StringUtils.isEmpty(language)){ //分割请求参数 String[] split = language.split(\"_\"); //国家，地区 locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { } } 然后在mvcconfig让它生效 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); } @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } 在网页中添加配置 中文 English 验证生效了 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-05-06 19:15:43 "},"javaweb/SpringBoot学习2.html":{"url":"javaweb/SpringBoot学习2.html","title":"SpringBoot2","keywords":"","body":"SpringBoot学习2（Kuangshen） 13.数据库服务 JDBC MyBatis Druid Shiro：安全 Spring Security 异步任务 Swagger Dubbo+Zookeeper Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2022-05-06 19:13:13 "}}