{"./":{"url":"./","title":"Introduction","keywords":"","body":"自我 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-12 09:58:11 "},"Head-First-设计模式1-----策略模式.html":{"url":"Head-First-设计模式1-----策略模式.html","title":"Head-First-设计模式1-----策略模式","keywords":"","body":"本文参照《Head First 设计模式》，转载请注明出处 对于整个系列，我们按照这本书的设计逻辑，使用情景分析的方式来描述，并且穿插使用一些问题，总结的方式来讲述。并且所有的开发源码，都会托管到github上。 项目地址：https://github.com/jixiang52002/HFDesignPattern 1.引文 Joe的公司是做模拟鸭子活动的游戏而出名，这款游戏取名为SimUDuck，这款游戏具有非常多的鸭子，一边游泳一边呱呱叫。这里的设计采用了标准的OO（Object Oriented，面向对象）的方式编写，这里有一个鸭子的超类（SuperClass），后续所有的鸭子都必须继承这个超类。 OO面向对象模型 继承 这时，公司的高层们想要通过模拟会飞的鸭子来追求行业的领先。然后Joe的项目经理拍着胸脯告诉主管，Joe很快就可以搞定，“有了OO什么都不怕” Joe接收到任务后，想出了一个办法：“我仅需要在Duck这个超类中加上Fly()的方法，然后所有的鸭子都可以飞了”。然后他的设计模型就改成以下的样子 这样看起来貌似没有什么问题的，然后可怕的问题发生了。。。。 用户反馈，自己的橡皮鸭和木鸭居然也可以飞起来！！！ 那么，到底是为何导致了这个可怕的问题？ 我们来分析一下：由于Joe在Duck超类中加上fly方法，导致所有的子类都会继承该方法，这就导致了原本不会飞的橡皮鸭和木鸭也具有飞行能力，显然为了提高复用性使用的继承方式，并未达到完美得结果。 继承+覆盖 Joe在思考后，又得出一个方案，那就是在橡皮鸭中将fly方法覆盖掉，不做任何操作，这样原有的RubberDuck类中架构就变成如下： 然后，业务的需求又需要加入木鸭（DecoyDuck），它不会叫也不会飞。苦逼的Joe又要把木鸭（DecoyDuck)中quark方法覆盖，这样DecoyDuck中的类结构就变成如下： 但是我们会发觉，如果以后有新的业务，甚至于fly方法中出现一个bug，或者需要删除fly相关的业务，所有相关代码都需要修改，在大型项目中，这都导致非常可怕的维护问题。那么，到底该怎么办 接口 “这不就相当于让我根据用户手机壳颜色换主题吗？”，可怜的Joe在快被想要冲上去打产品经理的时候（皮一下。。。）。脑子突然想起一件神器，他决定试试。他的方法就是使用接口（Interface），将fly分离出来，放进一个Flyable接口中。针对于quark方法，也可以这样分离进Quarkable接口中， 虽然这样看起来满足了我们之前所提到的所有需求，但是这样一来重复代码量会非常可怕，如果有上万个Duck子类，Joe一定会发疯的。所有，这个方法虽然看起来很好，但是一旦某个方法或者行为发生改变，我们需要定位到所有实现该方法的类中去修改对应的代码，这很容易导致bug的发生。 那么，到底有没有一种能够建立软件的有效方法，能够让我们可以对既有的项目在影响最小的情况下修改他的业务逻辑，这样我们能够花很少的时间去修改代码。 2.策略模式 第一设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混合在一起。 按照以上的原则进行设计，代码发生变化引起的后果会非常小，整个项目会特别具有弹性。 这个原则不仅仅适用于策略模式，对于之后讲解的模式同样也是核心的指导方向。那么我们继续Joe所遇到的Duck问题。 2.1分开变化的和不会变化的 我们很清楚，Duck类内部的fly()和quark()伴随着鸭子的不同会发生改变，其他模块是不变的。为了要把这两个变化的行为从Duck类中分开，我们把它们从Duck类中抽离出来，建议一组新类用来代表每一个行为。 那么，问题来了。如何设计那组实现飞行行为和呱呱叫行为的一组类呢？ 这里就需要提及第二设计原则 第二设计原则 针对于接口编程，不针对实现编程 这里我们希望的是在创建具体的Duck类的时候，可以动态的生成对应的行为。打个比方，我们想要产生一个新的绿头鸭，将制定类型的飞行行为赋予给它。这就说明，在Duck类中，我们需要包含定义Duck行为的方法，这样在运行的时候，我们就可以动态去改变绿头鸭的行为。 所以这里我们使用两个接口来代表两个行为，这里定义为 FlyBehavior和QuarkBehavior，行为的每次实现，都将实现对应的接口。 但是接口类是没有方法体的，也就是说，我们需要一组类实现对应的行为，这些专用来实现类似FlyBehavior和QuarkBehavior的一组类，我们称为行为类。 这里提到的接口类并非严格意义上Java中的接口（Interface），可以理解为抽象类或接口。这里我们可以理解为： \"针对接口编程\"真正的意思是“针对超类型（supertype）编程” 这里讲得有点难以理解，我们对比一下针对实现编程和针对接口编程的区别： //针对实现编程 Dog dog=new Dog(); dog.bark(); //针对接口编程 Animal animal=new Dog(); animal.makeSoud(); 2.2实现鸭子的行为（代码） 从上面的讲解，我们可以理解可变部分是fly和quack两种方法。不可变为Duck类。那么这里我们需要使用两个接口FlyBehavior和QuackBehavior，还有一些列他们对应的行为类，具体的结构逻辑如下图： 这设计有两个很明显的优势： 可以让飞行和呱呱的叫的动作可以被其他对象复用，因为这些行为已经与鸭子类无关。也就是解耦 我们能够在不影响原有的行为类的情况下新增一些行为。也就是具备了弹性和可拓展性 拓展几个概念： 耦合指的就是两个类之间的联系的紧密程度 解耦指的是解除类之间的直接关系，将直接关系转换成间接关系 想要了解的可以参考这篇文章：https://blog.csdn.net/qq_24499615/article/details/77821896 接下来分别将FlyBehavior,FlyWithWings,FlyNoWay分别贴下 ``` public interface FlyBehavior { //飞行 public void fly(); } public class FlyWithWings implements FlyBehavior{ public void fly() { System.out.println(\"I am flying!\"); } } ``` public class FlyNoWay implements FlyBehavior { public void fly() { System.out.println(\"I can't fly!\"); } } 接下来将QuackBehavior，Quack，MuteQuack，Squeak类的代码分别贴下： public interface QuackBehavior { //呱呱叫 public void quack(); } public class Quack implements QuackBehavior { public void quack() { System.out.println(\"Quack\"); } } public class MuteQuack implements QuackBehavior { public void quack() { System.out.println(\">\"); } } public class Squeak implements QuackBehavior { public void quack() { System.out.println(\"Squeak\"); } } 到这里将fly和quack的接口类和行为类完成。 2.3组合鸭子行为 在前面2.2我们将飞行（fly）和呱呱叫（quack）的动作\"委托\"（delegate）给其他接口类处理，而并非在Duck类（或者子类）中定于fly和quack方法。那么到底该怎么把行为组合进Duck中？ 1.首先在Duck类中增加两个“实例变量”，分别为flyBehavior和quackBehavior，声明为接口类型（注意不是具体类的实现类型），每个Duck（或其子类）会动态的设置这些变量以在运行时引用正确的行为类型（如FlyWithWings，Squeak等）。Duck类的类结构如下 2.那么，就开始实现Duck类 public abstract class Duck { //为行为接口类型声明两个引用变量，所有的鸭子（或子类）都继承它们 FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck(){ } public abstract void display(); public void performQuck(){ //委托给行为处理 quackBehavior.quack(); } public void performFly(){ //委托给行为处理 flyBehavior.fly(); } public void swim(){ System.out.println(\"All ducks float\"); } } 然后我们实现一个MallardDuck类来实现组合， public class MallardDuck extends Duck{ public MallardDuck(){ //使用FlyWithWings作为其FlyBehavior类型 flyBehavior=new FlyWithWings(); //绿头鸭使用Quck类处理呱呱叫， //所以当performQuack被调用时，叫这个行为被委托给Quck对象 quackBehavior=new Quack(); } /* * 因为MallardDuck继承自Duck类 * ，所以具备flyBehavior与quackBehavior实例变量 */ public void display() { // TODO Auto-generated method stub } } 当然构造器内还是需要实现具体行为类，这在之后的模式中会提供相应的解决方案，之后我们会回归到这个问题继续解决这个问题。 到这里，组合鸭子类已经实现。 3.测试效果 这里我们编译测试类 ``` public class MiniDuckSimilator { public static void main(String[] args) { Duck mallerdDuck=new MallardDuck(); //一下代码是将具体的行为委托给对应的行为类处理行为 mallerdDuck.performQuck(); mallerdDuck.performFly(); } } ![运行结果](https://upload-images.jianshu.io/upload_images/2326194-d4b68c3aeb1df28f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) #2.4 动态行为设定 在之前的实现中我们是在Duck的具体子类中实现FlyBehavior和QuackBehavior的行为，但是Duck失去了动态设定的功能，对于追求完美的程序员来说是不可饶恕的。所以急切需要通过一个方法动态设定行为，而并非是在鸭子（Duck）的构造器中去实例化。这里推荐一个方法-----**设定方法（setter method）** * 1. 在Duck类中增加两个新方法 setFlyBehavior()和setQuckBehavior().对于Duck的类结构修改如下 ![image.png](https://upload-images.jianshu.io/upload_images/2326194-7d5c581118a4372b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 具体修改如下 public abstract class Duck { //为行为接口类型声明两个引用变量，所有的鸭子（或子类）都继承它们 FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck(){ } public abstract void display(); public void performQuck(){ //委托给行为处理 quackBehavior.quack(); } public void performFly(){ //委托给行为处理 flyBehavior.fly(); } public void setFlyBehavior(FlyBehavior flyBehavior){ this.flyBehavior=flyBehavior; } public void setQuackBehavior(QuackBehavior quackBehavior){ this.quackBehavior=quackBehavior; } public void swim(){ System.out.println(\"All ducks float\"); } } * 2.创建一个新的鸭子模型：模型鸭（ModelDuck） public class ModelDuck extends Duck{ public ModelDuck(){ flyBehavior=new FlyNoWay(); quackBehavior=new Quack(); } public void display() { System.out.println(\"I'm a model duck\"); } } * 3.新建立一个新的FlyBehavior类型 FlyRocketPowered public class FlyRocketPowered implements FlyBehavior{ public void fly() { System.out.println(\"I'm flying with a rocket!\"); } } * 4.修改测试类MiniDuckSimulator，加上模型鸭，并令模型鸭具备火箭动力 public class MiniDuckSimilator { public static void main(String[] args) { Duck mallerdDuck=new MallardDuck(); //一下代码是将具体的行为委托给对应的行为类处理行为 mallerdDuck.performQuck(); mallerdDuck.performFly(); Duck modelDuck=new ModelDuck(); //第一次会使用构造参数里的飞行模式 modelDuck.performFly(); modelDuck.setFlyBehavior(new FlyRocketPowered()); //模型鸭具备火箭飞行能力 modelDuck.performFly(); } } ``` 运行结果： 到这里我们发现鸭子模型中我们使用到类的组合使用，而这里我们涉及到第三个设计原则： 第三个设计原则 多用组合，少用继承 正如我们所见，组合所建立的系统具备极大的弹性，不仅仅可以将行为封装为一系列的行为类，更可以动态改变行为，只需要组合的行为对象是符合正确的行为接口标准的。 3.策略模式讲解 总结之前的三个设计原则： 第一设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混合在一起。 第二设计原则 针对于接口编程，不针对实现编程 第三设计原则 多用组合，少用继承 总结这三条原则结合起来就是我们学习的第一个模式： 策略模式 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-12 15:13:54 "},"Head-First-设计模式2---观察者（Observer）模式.html":{"url":"Head-First-设计模式2---观察者（Observer）模式.html","title":"Head-First-设计模式2---观察者（Observer）模式","keywords":"","body":"本文参照《Head First 设计模式》，转载请注明出处 对于整个系列，我们按照这本书的设计逻辑，使用情景分析的方式来描述，并且穿插使用一些问题，总结的方式来讲述。并且所有的开发源码，都会托管到github上。 项目地址：https://github.com/jixiang52002/HFDesignPattern 前一章主要讲解了设计模式入门和最常用的一个模式-----策略模式，并结合Joe的鸭子模型进行分析，想要了解的朋友可以回去回看一下。 这里我们将继续介绍一种可以帮助对象知悉现状，不会错过该对象感兴趣的事。甚至对象可以自己决定是都要继续接受通知。有过设计模式学习经验的人会脱口而出-----观察者模式。对的，接下来我们将了解一个新的设计模式，也就是观察者模式。 1.引言 最近你的团队获取了一个新的合约，需要负责建立一个Weather-O-Rama公司的下一代气象站----Internet气象观测站。 合约内容如下： 恭喜贵公司获选为敝公司建立下一代Internet气象观测站！该气象站必须建立在我们专利申请的WeatherData对象上，由WeatherData对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望贵公司能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。当WeatherData对象获取到最新的测量数据时，三种布告板必须实时更新。 而且，这是一个可以拓展的气象站，Weather-O-Rama气象站希望公布一组API，让其他开发人员可以写出自己的气象布告板，并插入此应用中我们希望贵公司可以提供这样的API。 Weather-O-Rama气象站有很好的商业运营模式：一旦客户上钩，他们使用每个布告板都要付钱最好的部分就是，为了感谢贵公司建立此系统，我们将以公司的认股权支付你。 我们期待看到你的设计和应用的alpha版本。 附注：我们正在通宵整理WeatherData源文件给你们。 1.1需求分析 根据开发的经验，我们首先分析Weather-O-Rama公司的需求： 此系统有三个部分组成：气象站（获取实际的气象数据的物理组成），WeatherData对象（追踪来自气象站的数据，并更新布告板）和布告板（显示目前天气状况展示给用户） 项目应用中，开发者需要利用WeatherData去实时获取气象数据，并且更新三个布告板：目前气象，气象统计和天气预报。 系统必须具备很高的可拓展性，让其他的开发人员可以建立定制的布告板，用户可以随心所欲地添加或删除任何布告板。 我们初始设计结构如下： 1.2WeatherData类 第二天，Weather-O-Rama公司发送过来WeatherData的源码，其结构如下图 其中measurementsChanged（）方法在气象测试更新时，被调用。 1.3错误的编码方式 首先，我们从大部分不懂设计模式的开发者常用的设计方式开始。 根据Weather-O-Rama气象站开发人员的需求暗示，在measurementsChanged()方法中添加相关的代码： public class WeatherData { private float temperature;//温度 private float humidity;//湿度 private float pressure;//气压 private CurrentConditionsDisplay currentConditionsDisplay;//目前状态布告板 private StatisticsDisplay statisticsDisplay;//统计布告板 private ForecastDisplay forecastDisplay;//预测布告板 public WeatherData(CurrentConditionsDisplay currentConditionsDisplay ,StatisticsDisplay statisticsDisplay ,ForecastDisplay forecastDisplay){ this.currentConditionsDisplay=currentConditionsDisplay; this.statisticsDisplay=statisticsDisplay; this.forecastDisplay=forecastDisplay; } public float getTemperature() { return temperature; } public float getHumidity(){ return humidity; } public float getPressure(){ return pressure; } //实例变量声明 public void measurementsChanged(){ //调用WeatherData的三个getter方法获取最近的测量值 float temp=getTemperature(); float humidity=getHumidity(); float pressure=getPressure(); currentConditionsDisplay.update(temp,humidity,pressure); statisticsDisplay.update(temp,humidity,pressure); forecastDisplay.update(temp,humidity,pressure); } //通知发生变化 public void setMeasurements(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; measurementsChanged(); } } 回顾第一章的三个设计原则，我们发现这里违反了几个原则 第一设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混合在一起。 第二设计原则 针对于接口编程，不针对实现编程 第三设计原则 多用组合，少用继承 在这里我们使用了针对实现编程，并且没有将变化部分独立出来，这样会导致我们以后在增加或删除布告板时必须修改应用程序。而且，最重要的是，我们牺牲了可拓展性。 既然这里我们提到了要使用观察者模式来解决问题，那么该如何下手。并且，什么是观察者模式？ 2.观察者模式 2.1认识观察者模式 为了方便理解，我们从日常生活中常遇到的情形来理解观察者模式，这里我们使用生活常见的报纸和杂志订阅业务逻辑来理解： 报社的业务在于出版报纸 订阅报纸的用户，只要对应报社有新的报纸出版，就会给你送来 当用户不想继续订阅报纸，可以直接取消订阅。那么之后就算有新的报纸出版，也不会送给对应用户了。 只要报社一直存在，任何用户都可以自由订阅或取消订阅报纸 从上面的逻辑我们分析出，这里由以下部分组成，报社，用户，订阅。将其抽象出来就i是：出版者，订阅者，订阅。这里观察者模式的雏形已经出来了。 出版者+订阅者=观察者模式 如果上面已经理解了报社报纸订阅的逻辑，也可以很快知道观察者模式是什么。只是在其中名称会有差异，前面提到的“出版者”我们可以称为“主题（Subject）”或“被观察者（Observable）”（后一个更加常用），“订阅者”我们称为“观察者（Observer）”，这里我们采用类UML的结构图来解释： 2.2 观察者模式注册/取消注册 场景1： 某一天，鸭子对象觉得自己的朋友都订阅了主题，自己也想称为一个观察者。于是告诉主题，它想当一个观察者。完成订阅后，鸭子也成为一个观察者了。 这样当主题数据发生变化时，鸭子对象也可以得到通知了！！ 场景2： 老鼠对象厌烦了每天都被主题烦，决定从观察者序列离开，于是它告诉主题它想离开观察者行列，主题将它从观察者中除名。 之后主题数据发生变化时，不会再通知老鼠对象。 上面的两个情形分别对应了注册和取消注册，这也是观察者模式最重要的两个概念。注册后的对象我们才可以称为观察者。观察者取消注册后也不能称为观察者。 2.3 观察者模式定义 通过报纸业务和对象订阅的例子，我们可以勾勒出观察者模式的基本概念。 观察者模式定义了对象之间的一对多的依赖，这样一来，当一个对象改变状态时，它所有的依赖者都会收到通知并自动更新。 主题/被观察者和观察者之间定义了一对多的关系。观察者依赖于主题/被观察者。一旦主题/被观察者数据发生改变的时候，观察者就会收到通知。那么，如何实现观察者和主题/被观察者呢？ 2.4 观察者模式实现 由于网络上的实现观察者的方式非常多，我们这里采取比较容易理解的方式Subject和Observer。对于更高级的使用方式，可以百度。 接下来我们来看看基于Subject和Observer的类图结构： 3. 设计气象站 到这里我们再回到当初的问题，气象站中结构模型为一对多模型，其中WeatherData为气象模型中的“一”，而“多”也就对应了这里用来展示天气监测数据的各种布告板。相对于之前的针对实现的方式，使用观察者模式来设计会更加符合需求。优先我们给出新的气象站模型。 3.1实现气象站 依照前面的设计结构图，最终来实现具体代码结构 1.Subject public interface Subject { //注册观察者 public void registerObserver(Observer o); //删除观察者 public void removeObserver(Observer o); //当主题发生数据变化时，通知所有观察 public void notifyObservers(); } 2.Observer public interface Observer { /** * * update:当气象站的观测数据发生改变时，这个方法会被调用 * @param temp 温度 * @param hunmidity 湿度 * @param pressure 气压 * @since JDK 1.6 */ public void update(float temp,float hunmidity,float pressure); } 3.DisplayElement public interface DisplayElement { //当布告板需要展示时，调用此方法时 public void display(); } 4.新的WeatherData1 public class WeatherData1 implements Subject{ private ArrayList observers; private float temperature; private float humiditty; private float pressure; public WeatherData1(){ observers=new ArrayList(); } //注册 public void registerObserver(Observer o) { observers.add(o); } //删除 public void removeObserver(Observer o) { int i=observers.indexOf(o); if(i>=0){ observers.remove(i); } } //通知观察者数据变化 public void notifyObservers() { for(int i=0;i5.CurrentConditionsDisplay public class CurrentConditionsDisplay implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData){ this.weatherData=weatherData; weatherData.registerObserver(this); } /** * * update:更新布告板内容 * @author 吉祥 * @param temperature * @param humidity * @param pressure * @since JDK 1.6 */ public void update(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; display(); } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Current conditons:\"+temperature +\"F degrees and \"+humidity+\"% humidity\"); } } 6.ForecastDisplay public class ForecastDisplay implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Subject weatherData; public ForecastDisplay(Subject weatherData){ this.weatherData=weatherData; weatherData.registerObserver(this); } /** * * update:更新布告板内容 * @author 吉祥 * @param temperature * @param humidity * @param pressure * @since JDK 1.6 */ public void update(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; display(); } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Forecast: More of the same\"); } } 7.StatisticsDisplay public class StatisticsDisplay implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Subject weatherData; public StatisticsDisplay(SubjectweatherData){ this.weatherData=weatherData; weatherData.registerObserver(this); } /** * * update:更新布告板内容 * @author 吉祥 * @param temperature * @param humidity * @param pressure * @since JDK 1.6 */ public void update(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; display(); } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Avg/Max/Min temperature= \"+temperature +\"/\"+temperature+\"/\"+temperature); } } ps:这里在Observer中使用Subject原因在于方便以后的取消注册。 最后我们建立一个测试类WeatherStation来进行测试 public class WeatherStation { public static void main(String[] args){ WeatherData1 weatherData=new WeatherData1(); CurrentConditionsDisplay currentConditionsDisplay=new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay=new StatisticsDisplay(weatherData); ForecastDisplay forecastDisplay=new ForecastDisplay(weatherData); weatherData.setMeasurements(80, 65, 30.4f); weatherData.setMeasurements(82, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.2f); } } 最终结果如下 到这里我们已经讲解完观察者模式的一种实现方式。但是这我们也提出一个问题，用来发散。 是否能够在主题中提供向外的可以让观察者自己获取自己想要数据，而并非将所有的数据都推送给观察者？也就是在Push（推）的同时我们也可以pull（拉）。 4.Java内置的观察者模式 刚才的问题，其实熟悉Java语言的开发者会发现，在Java中已经有相应的模式，如果熟悉的可以直接跳过本章。 在java.util包下有Observer和Observable类，这两个类的结构跟我们遇到的Subject和Observer模型有些类似。甚至可是随意使用push（推）或者pull（拉） 这里我们使用在线的Java API网站在线Java API文档 首先查询Observer的API 这个与我们所写的Observer结构几乎相同，只是在推送是把Observable类一起推送，这样用户既可以push也可以使用pull的方式。那么Observable的结构呢 我们发现这里Observable是类与我们之前Subject作为接口的方式稍微有区别；并且Observable类其他方法更全。那么使用类的方式和使用接口的影响我们在后面会继续讲。并且这里我们关注setChanged（）方法告诉被观察者的数据发生改变 那么，如果要使用Java中自带的观察者模式来修改原有气象站业务会如何。 首先，我们来分析更改后气象站的模型： 4.1Java内置观察者模式运作模式 相对于于之前Subject和Observer的模式，Java内置自带的观察者模式运行稍微有些差异。 将对象变成观察者只需要实现Observer（java.util.Observer）接口，然后调用任何Observable的addObserver()方法即可。如果要删除观察者，调用deleteObserver()即可。 被观察者若要推送通知，需要对象继承Observable（java.util.Observable）类，并先调用setChanged(),首先标记状态已经改变。然后调用notifyObservers()方法中的一个：notifyObservers()(通知观察者pull数据)或notifyObserers(Object object)(通知观察者push数据) 那么作为观察者如何处理被观察者推送出的数据呢。 这里逻辑如下： 观察者（Observer）必须在update（Observable o,Object object）.前一个参数用来让观察者知道是哪个被观察者推送数据。后一个object为推送数据，允许为null。 4.2 setChanged() 在Observable类中setChanged()方法一开始我也有疑惑，为何在推送之前需要调用该方法。后来查阅资料和Java API发现它很好的一个用处。我们先来查看java的源码 这里必须标记为true才会推送消息，那么这个到底有何好处，我们拿气象站模型来分析。 如果没有setChanged方法，也是之前的Subject和Observer模型里，一旦数据发生细微的变化，我们都会对所有的观察者进行推送。如果我们需要在温度变化1摄氏度以上才发送推送，调用setChanged（）方法更加有效。当然，这个功能使用场景很少，但是也不排除会用到。当然更改Object和Observer模型也是可以做到这个效果的！！！ 4.3 Java内置观察者更改气象站 那么利用气象站模型来实际操作一下，依照之前的模型我们代码应该如下 1.WeatherData2 public class WeatherData2 extends Observable{ private float temperature; private float humidity; private float pressure; //构造器不需要为了记住观察者建立数据模型 public WeatherData2(){ } public void measurementsChanged(){ //在调用notifyObserver()需要指示状态已经更改了 setChanged(); //这里未使用notifyObserver(object),所以数据采用拉的逻辑 notifyObservers(this); } public void setMeasurements(float temperature,float humidity,float pressure){ this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; measurementsChanged(); } //以下方法为pull操作提供 public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; } } 2.CurrentConditionsDisplay1 public class CurrentConditionsDisplay1 implements Observer,DisplayElement{ private Observable observable; private float temperature; private float humidity; private float pressure; //构造器需要传入Observable参数，并登记成为观察者 public CurrentConditionsDisplay1(Observable observable){ this.observable=observable; observable.addObserver(this); } //update方法增加Observable和数据对象作为参数 public void update(Observable o, Object arg) { if(arg instanceof WeatherData2){ WeatherData2 weatherData2=(WeatherData2) arg; this.temperature=weatherData2.getTemperature(); this.humidity=weatherData2.getHumidity(); this.pressure=weatherData2.getPressure(); display(); } } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Current conditons:\"+temperature +\"F degrees and \"+humidity+\"% humidity\"); } } 3.ForecastDisplay1 public class ForecastDisplay1 implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Observable observable; public ForecastDisplay1(Observable observable){ this.observable=observable; observable.addObserver(this); } public void update(Observable o,Object arg){ if(arg instanceof WeatherData2){ WeatherData2 weatherData2=(WeatherData2) arg; this.temperature=weatherData2.getTemperature(); this.humidity=weatherData2.getHumidity(); this.pressure=weatherData2.getPressure(); display(); } } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Forecast: More of the same\"); } } 4.StatisticsDisplay1 public class StatisticsDisplay1 implements Observer,DisplayElement{ private float temperature; private float humidity; private float pressure; private Observable observable; public StatisticsDisplay1(Observable observable){ this.observable=observable; observable.addObserver(this); } public void update(Observable o,Object arg){ if(arg instanceof WeatherData2){ WeatherData2 weatherData2=(WeatherData2) arg; this.temperature=weatherData2.getTemperature(); this.humidity=weatherData2.getHumidity(); this.pressure=weatherData2.getPressure(); display(); } } /** * * display:展示布告板内容 * @author 吉祥 * @since JDK 1.6 */ public void display(){ System.out.println(\"Avg/Max/Min temperature= \"+temperature +\"/\"+temperature+\"/\"+temperature); } } 最后进行测试： WeatherStation1 public class WeatherStation1 { public static void main(String[] args){ WeatherData2 weatherData=new WeatherData2(); CurrentConditionsDisplay1 currentConditionsDisplay=new CurrentConditionsDisplay1(weatherData); StatisticsDisplay1 statisticsDisplay=new StatisticsDisplay1(weatherData); ForecastDisplay1 forecastDisplay=new ForecastDisplay1(weatherData); weatherData.setMeasurements(80, 65, 30.4f); weatherData.setMeasurements(82, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.2f); } } 结果最终如下： 我们对比之前Subject和Observer的观察者模式会发现两者输出顺序不一样，这是为什么？ 其实java.util.Observable不依赖于观察者被通知的顺序的，并且实现了他的notifyObserver()方法，这会导致通知观察者的顺序不同于Subject和Observer模型在具体类实现notifyObserver()方法。其实两者都没有任何的代码误差，只是实现的方式不同导致不同的结果。 但是java.util.Observable类却违背了之前第一章中针对接口编程，而非针对实现编程。恐怖的是，它也没有接口实现，这就导致它的使用具有很高的局限性和低复用性。如果一个对象不仅仅是被观察者，同时还是另一个超类的子类的时候，我们无法使用多继承的方式来实现。我们如果自行拓展的话，你会发现setChanged()方法是protected方法，这就表示只有java.util.Observable自身和其子类才可以使用这个方法。这就违反了第二个设计原则---------\"多用组合，少用继承\"。这也是我一般不会使用Java自带的设计者模式的原因。 现在比较流行的观察者模式，也就是RxJava，但是由于这个框架涉及不仅仅有观察这模式，在之后整个设计模式整理玩不后，我会集中再讲。 5.总结 到此，观察者模式的讲解已经全部讲解完成。总结一下。 第四设计原则 为交互对象之间的松耦合涉及而努力 观察者模式 在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。 相应的资料和代码托管地址https://github.com/jixiang52002/HFDesignPattern Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-20 10:48:54 "},"Head-First-设计模式3----装饰者模式.html":{"url":"Head-First-设计模式3----装饰者模式.html","title":"Head-First-设计模式3----装饰者模式","keywords":"","body":"本文参照《Head First 设计模式》，转载请注明出处 对于整个系列，我们按照这本书的设计逻辑，使用情景分析的方式来描述，并且穿插使用一些问题，总结的方式来讲述。并且所有的开发源码，都会托管到github上。 项目地址：https://github.com/jixiang52002/HFDesignPattern 回顾上一篇文章讲解了设计模式中常用的一种模式------观察者模式。并结合气象站设计进行实战解析，并且从自己设计到JAVA自带设计模式做了讲解。想要了解的朋友可以回去回看一下。 本章我们会继续前面的话题，有关典型的继承滥用问题。这一章会讲解如何使用对象组合的方式，如何在运行时候做装饰类。在熟悉装饰技巧后，我们能够在原本不修改任何底层的代码，却可以给原有对象赋予新的职能。你会说，这不就是“装饰者模式”。没错，接下来就是装饰者模式的ShowTime时间。 前言 欢迎来到星巴兹咖啡，该公司是世界上以扩张速度最快而闻名的咖啡连锁店。但是最近这家著名的咖啡公司遇到一个巨大的问题，因为扩展速度太快了，他们准备更新订单系统，以合乎他们的饮料供应需求。 他们本来的设计方式如下： 然后客户购买咖啡时，可以要求在其中加入任何调料，例如：奶茶，牛奶，豆浆。星巴兹根据业务需求会计算相应的费用。这就要求订单系统必须考虑到这些调料的部分。 然后我们就看到他们的第一个尝试设计： 是不是有一种犯了密集恐惧症的感觉，整完全就是“类爆炸”。 那么我们分析一下，这种设计方式违反了什么设计原则?没错，违反了以下两个原则: 第二设计原则 针对于接口编程，不针对实现编程 第三设计原则 多用组合，少用继承 那么我们应该怎么修改这个设计呢？ 利用继承对Beverage类进行改造 首先，我们考虑对基类Beverage类进行修改，我们根据前面“类爆炸”进行分析。主要饮料包含各种调料（牛奶，豆浆，摩卡，奶泡。。。。）。 所以修改后的Beverage类的结构如下： Beverage类具体实现如下： public class Beverage { protected String description;//饮料简介 protected boolean milk=false;//是否有牛奶 protected boolean soy=false;//是否有豆浆 protected boolean cocha=false;//是否有摩卡 protected boolean whip=false;//是否有奶泡 protected double milkCost=1.01;//牛奶价格 protected double soyCost=1.03;//豆浆价格 protected double cochaCost=2.23;//摩卡价格 protected double whipCost=0.89;//奶泡价格 public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public boolean hasMilk() { return milk; } public void setMilk(boolean milk) { this.milk = milk; } public boolean hasSoy() { return soy; } public void setSoy(boolean soy) { this.soy = soy; } public boolean hasCocha() { return cocha; } public void setCocha(boolean cocha) { this.cocha = cocha; } public boolean hasWhip() { return whip; } public void setWhip(boolean whip) { this.whip = whip; } public double getCochaCost() { return cochaCost; } public void setCochaCost(double cochaCost) { this.cochaCost = cochaCost; } public double getWhipCost() { return whipCost; } public void setWhipCost(double whipCost) { this.whipCost = whipCost; } public double cost(){ double condiments=0.0; if(hasMilk()){//是否需要牛奶 condiments+=milkCost; } if(hasSoy()){//是否需要豆浆 condiments+=soyCost; } if(hasCocha()){//是否需要摩卡 condiments+=cochaCost; } if(hasWhip()){//是否需要奶泡 condiments+=whipCost; } return condiments; } } 实现其中一个子类DarkRoast： public class DarkRoast extends Beverage{ public DarkRoast(){ description=\"Most Excellent Dark Roast!\"; } public double cost(){ return 1.99+super.cost(); } } 看起来很完美，也能满足现有的业务需求，但是仔细思考一下，真的这样设计不会出错？ 回答肯定是会出错。 第一，一旦调料的价格发生变化，会导致我们队原有代码进行大改。 第二，一旦出现新的调料，我们就需要加上新的方法，并需要改变超类Beverage类中cost（）方法。 第三，如果星巴兹咖啡研发新的饮料。对于这些饮料而言，某些调料可能并不合适，但是子类仍然会继承那些本就不合适的方法，例如我就想要一杯水，加奶泡（hasWhip）就不合适。 第四，如果用户需要双倍的摩卡咖啡，又应该怎么办呢？ 开放-关闭原则 到这里，我们可以推出最重要的设计原则之一： 第五设计原则 类应该对拓展开放，对修改关闭。 那么什么是开放，什么又是关闭？开放就是允许你使用任何行为来拓展类，如果需求更改（这是无法避免的），就可以进行拓展！关闭在于我们花费很多时间完成开发，并且已经测试发布，针对后续更改，我们必须关闭原有代码防止被修改，避免造成已经测试发布的源码产生新的bug。 综合上述说法，我们的目标在于允许类拓展，并且在不修改原有代码的情况下，就可以搭配新的行为。如果能实现这样的目标，带来的好处将相当可观。在于代码会具备弹性来应对需求改变，可以接受增加新的功能用来实现改变的需求。没错，这就是拓展开放，修改关闭。 那么有没有可以参照的实例可以分析呢？有，就在第二篇我们介绍观察者模式时，我们介绍到可以通过增加新的观察者用来拓展主题，并且无需向原主题进行修改。 我们是否需要每个模块都设计成开放--关闭原则？不用，也很难办到（这样的人我们称为“不用设计模式会死病”）。因为想要完全符合开放-关闭原则，会引入大量的抽象层，增加原有代码的复杂度。我们应该区分设计中可能改变的部分和不改变的部分（第一设计原则），针对改变部分使用开放--关闭原则。 装饰模式 这里，就到了开放--关闭原则的运用模式-----装饰者模式。首先我们还是从星巴兹咖啡的案例来做一个简单的分析。 分析之前两个版本（类爆炸和继承大法）的实现方式，并不能适用于所有的子类。 这就需要一个新的设计思路。这里，我们将以饮料为主，然后运行的时候以饮料来“装饰”饮料。举个栗子，如果影虎需要摩卡和奶泡深焙咖啡，那么要做的是： 拿一个深焙咖啡（DarkRosat）对象 以摩卡（Mocha）对象装饰它 以奶泡（Whip）对象装饰它 调用cost（）方法，并依赖委托（delegate）将调料的价钱加上去。 具体的实现我们用一张图来展示 首先我们构建DarkRoast对象 假如顾客需要摩卡（Mocha），再建立一个Mocha对象，并用DarkRoast对象包起来。 如果顾客也想要奶泡（Whip）,就建立一个Whip装饰者，并将它用Mocha对象包起来。 最后运算客户的账单的时候，通过最外层的装饰者Whip的cost（）就可以办得到。Whip的cost（）会委托他的装饰对象（Mocha）计算出价格，再加上奶泡（Whip）的价格。 通过对星巴兹咖啡的设计方案分析，我们可以发现，所有的装饰类都具备以下几个特点： 装饰者和被装饰对象有相同的超类型。 你可以用一个或多个装饰者包装一个对象。 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它。 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象 什么是装饰模式呢？我们首先来看看装饰模式的定义： 装饰者模式动态地将责任附加到对象上。 若要扩展功能，装饰者提供了比继承更有弹性 的替代方案。 定义虽然已经定义了装饰者模式的“角色”，但是未说明怎么在我们的实现中如何使用它们。我们继续在星巴兹咖啡中来熟悉相关的操作。 其中装饰者层级可以无限发展下去，不是如图中一般两层关系。并且组件也并非只有一个，可以存在多个。 现在我们就在星巴兹咖啡里运用装饰者模式： 到这里，我们队装饰者模式已经有了一个基本的认识。那么我们已经解决了上面提到的四个问题： 第一，一旦调料的价格发生变化，会导致我们队原有代码进行大改。 第二，一旦出现新的调料，我们就需要加上新的方法，并需要改变超类Beverage类中cost（）方法。 第三，如果星巴兹咖啡研发新的饮料。对于这些饮料而言，某些调料可能并不合适，但是子类仍然会继承那些本就不合适的方法，例如我就想要一杯水，加奶泡（hasWhip）就不合适。 第四，如果用户需要双倍的摩卡咖啡，又应该怎么办呢？ 那么根据第四个问题，假如我们需要双倍摩卡豆浆奶泡拿铁咖啡时，该如何去运算账单呢？首先，我们先把前面的深度烘焙摩卡咖啡的设计图放在这里。 然后我们只需要将Mocha的装饰者加一，即可 实现星巴兹咖啡代码 前面已经把设计思想都设计出来了，接下来是将其具体实现了。首先从Beverage类下手 public abstract class Beverage1 { String description=\"Unknown Beverage\"; public String getDescription(){ return description; } public abstract double cost(); } Beverage类非常简单，然后再实现Condiment（调料类），该类为抽象类，也为装饰者类 public abstract class CondimentDecorator extends Beverage1{ //所有的调料装饰者都必须重新实现 getDescription()方法。 public abstract String getDescription(); } 前面已经有了饮料的基类，那么我们来实现一些具体的饮料类。首先从浓缩咖啡（Espresso））开始，这里需要重写cost()方法和getDescription（）方法 public class Espresso extends Beverage1{ public Espresso(){ //为了要设置饮料的描述，我 们写了一个构造器。记住， description实例变量继承自Beverage1 description=\"Espresso\"; } public double cost() { //最后，需要计算Espresso的价钱，现在不需要管调料的价钱，直接把Espresso的价格$1.99返回即可。 return 1.99; } } 再实现一个类似的饮料HouseBlend类。 public class HouseBlend extends Beverage1{ public HouseBlend(){ description=\"HouseBlend\"; } public double cost() { return 0.89; } } 重新设计DarkRoast1 public class DarkRoast1 extends Beverage1{ public DarkRoast1(){ description=\"DarkRoast1\"; } public double cost() { return 0.99; } } 接下来就是调料的代码，我们一开始已经实现了抽象组件类（Beverage），有了具体的组件（HouseBlend），也有了已经完成抽象装饰者（CondimentDecorator）。现在只需要实现具体的装饰者。首先我们先完成摩卡（Mocha） public class Mocha extends CondimentDecorator{ /** * 要让Mocha能够引用一个Beverage，采用以下做法 * 1.用一个实例记录饮料，也就是被装饰者 * 2.想办法让被装饰者（饮料）被记录在实例变量中。这里的做法是： * 把饮料当作构造器的参数，再由构造器将此饮料记录在实例变量中 */ Beverage1 beverage; public Mocha(Beverage1 beverage) { this.beverage=beverage; } public String getDescription() { //这里将调料也体现在相关参数中 return beverage.getDescription()+\",Mocha\"; } /** * 想要计算带摩卡的饮料的价格，需要调用委托给被装饰者，以计算价格， * 然后加上Mocha的价格，得到最终的结果。 */ public double cost() { return 0.21+beverage.cost(); } } 还有奶泡（Whip）类 public class Whip extends CondimentDecorator{ /** * 要让Whip能够引用一个Beverage，采用以下做法 * 1.用一个实例记录饮料，也就是被装饰者 * 2.想办法让被装饰者（饮料）被记录在实例变量中。这里的做法是： * 把饮料当作构造器的参数，再由构造器将此饮料记录在实例变量中 */ Beverage1 beverage; public Whip(Beverage1 beverage) { this.beverage=beverage; } public String getDescription() { //这里将调料也体现在相关参数中 return beverage.getDescription()+\",Whip\"; } /** * 想要计算带奶泡的饮料的价格，需要调用委托给被装饰者，以计算价格， * 然后加上Whip的价格，得到最终的结果。 */ public double cost() { return 0.22+beverage.cost(); } } 豆浆Soy类 public class Soy extends CondimentDecorator{ /** * 要让Soy能够引用一个Beverage，采用以下做法 * 1.用一个实例记录饮料，也就是被装饰者 * 2.想办法让被装饰者（饮料）被记录在实例变量中。这里的做法是： * 把饮料当作构造器的参数，再由构造器将此饮料记录在实例变量中 */ Beverage1 beverage; public Soy(Beverage1 beverage) { this.beverage=beverage; } public String getDescription() { //这里将调料也体现在相关参数中 return beverage.getDescription()+\",Soy\"; } /** * 想要计算带豆浆的饮料的价格，需要调用委托给被装饰者，以计算价格， * 然后加上Soy的价格，得到最终的结果。 */ public double cost() { return 0.21+beverage.cost(); } } 接下来就是调用测试类，具体实现如下： public class StarbuzzCoffe { public static void main(String[] args) { //订购一杯Espresso，不需要调料，打印他的价格和描述 Beverage1 beverage=new Espresso(); System.out.println(beverage.getDescription()+\"$\" +beverage.cost()); //开始装饰双倍摩卡+奶泡咖啡 Beverage1 beverage2=new DarkRoast1(); beverage2=new Mocha(beverage2); beverage2=new Mocha(beverage2); beverage2=new Whip(beverage2); System.out.println(beverage2.getDescription()+\"$\" +beverage2.cost()); // Beverage1 beverage3=new HouseBlend(); beverage3=new Soy(beverage3); beverage3=new Mocha(beverage3); beverage3=new Whip(beverage3); System.out.println(beverage3.getDescription()+\"$\" +beverage3.cost()); } } 运行结果： 到这里，我们已经完成装饰者模式对于星巴兹咖啡的改造。 Java中的真实装饰者 前面已经研究了装饰者模式的原理和实现方式，那么在JAVA语言本身是否有装饰者模式的使用范例呢，答案是肯定有的，那就是I/O流。 第一次查阅I/O源码，都会觉得类真多,而且一环嵌一环，阅读起来会非常麻烦。但是只要清楚I/O是根据装饰者模式设计，就很容易理解。我们先来看一下一个范例： 分析一下,其中BufferedInputStream及LineNumberInputStream都扩展自 FilterInputStream，而FilterInputStream是一个抽象的装饰类。这样看有些抽象，我们将其中的类按照装饰者模式进行结构化，方便理解。 我们发现，和星巴兹的设计相比，java.io其实并没有多大的差异。但是从java.io流我们也会发现装饰者模式一个非常严重的\"缺点\"：使用装饰者模式，常常会造成设计中有大量的小类，数量还非常多，这对于学习API的程序员来说就增加了学习难度和学习成本。但是，懂得装饰者模式以后会非常容易理解和设计相关的类。 设计自己的IO类 在理解装饰者模式和java.io的设计后，我们将磨炼下自己的熟悉程度，没错，就是自己设计一个Java I/O装饰者，需求如下： 编写一个装饰者，把输入流内的所有大写字符转成小写。举例：当读 取“ ASDFGHJKLQWERTYUIOPZXCVBNM”，装饰者会将它转成“ asdghjklqwertyuiopzxcvbnm”。具体的办法在于扩展FilterInputStream类，并覆盖read()方法就行了。 public class LowerCaseInputStream extends FilterInputStream{ public LowerCaseInputStream(InputStream inputStream){ super(inputStream); } public int read() throws IOException { int c=super.read(); //判断相关的字符是否为大写，并转为小写 return (c==-1?c:Character.toLowerCase((char)c)); } /** * *针对字符数组进行大写转小写操作 * @see java.io.FilterInputStream#read(byte[], int, int) */ public int read(byte[] b, int off, int len) throws IOException { int result=super.read(b,off,len); for(int i=off;i接下来我们构建测试类InputTest public class InputTest { public static void main(String[] args) { int c; try { InputStream inputStream=new LowerCaseInputStream(new BufferedInputStream(new FileInputStream(\"test.txt\"))); while((c=inputStream.read())>=0){ System.out.print((char)c); } } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 其中test.txt的内容可以自行编辑，放在项目根目录下我的内容原文为： 运行结果为： 5.总结 至此，我们已经掌握了装饰者模式的相关知识点。总结一下： 第五设计原则 类应该对拓展开放，对修改关闭。 装饰者模式动态地将责任附加到对象上。 若要扩展功能，装饰者提供了比继承更有弹性 的替代方案。 相应的资料和代码托管地址https://github.com/jixiang52002/HFDesignPattern Copyright © jiaojiao52002.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-20 10:48:54 "}}